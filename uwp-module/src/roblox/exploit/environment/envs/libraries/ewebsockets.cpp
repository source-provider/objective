#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <ixwebsocket/IXNetSystem.h>
#include <ixwebsocket/IXWebSocket.h>
#include <lualib.h>

class websocketClass {
public:
	lua_State* th = nullptr;
	bool connected = false;
	ix::WebSocket* webSocket;
	std::intptr_t onMessageRef;
	std::intptr_t onCloseRef;
	std::intptr_t threadRef;

	auto fireMessage(std::string message) -> void {
		if (!connected)
			return;

		lua_getref(th, onMessageRef);
		lua_getfield(th, -1, "Fire");
		lua_getref(th, onMessageRef);
		lua_pushlstring(th, message.c_str(), message.size());
		lua_pcall(th, 2, 0, 0);
		lua_settop(th, 0);
	}

	auto fireClose() -> void {
		if (!connected)
			return;

		connected = false;

		lua_getref(th, onCloseRef);
		lua_getfield(th, -1, "Fire");
		lua_getref(th, onCloseRef);
		lua_pcall(th, 1, 0, 0);
		lua_settop(th, 0);

		lua_unref(th, onMessageRef);
		lua_unref(th, onCloseRef);
		lua_unref(th, threadRef);
	}

	auto handleIndex(lua_State* L) -> std::intptr_t {
		if (!connected)
			return 0;

		luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
		checkType(L, 2, LUA_TSTRING);

		std::string idx = lua_tostring(L, 2);

		if (idx == "OnMessage") {
			lua_getref(L, this->onMessageRef);
			lua_getfield(L, -1, "Event");
			return 1;
		}
		else if (idx == "OnClose") {
			lua_getref(L, this->onCloseRef);
			lua_getfield(L, -1, "Event");
			return 1;
		}
		else if (idx == "Send") {
			lua_pushvalue(L, -10003);
			lua_pushcclosure(L,
				[](lua_State* L) -> std::intptr_t {
					luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
					checkType(L, 2, LUA_TSTRING);

					std::string data = lua_tostring(L, 1);

					websocketClass* webSocket = reinterpret_cast<websocketClass*>(lua_touserdata(L, -10003));
					webSocket->webSocket->send(data, true);

					return 0;
				}, obfuscate_str("WebSocket.Send"), 1);

			return 1;
		}
		else if (idx == "Close") {
			lua_pushvalue(L, -10003);
			lua_pushcclosure(L,
				[](lua_State* L) -> std::intptr_t {
					luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));

					websocketClass* webSocket = reinterpret_cast<websocketClass*>(lua_touserdata(L, -10003));
					webSocket->webSocket->close();

					return 0;
				}, obfuscate_str("WebSocket.Close"), 1);
			return 1;
		}

		return 0;
	};

	auto handleNewIndex(lua_State* L) -> std::intptr_t {
		luaL_error(L, "Unable to set property!");
		return 0;
	};
};

auto websocket_connect(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string url = lua_tostring(L, 1);
	websocketClass* webSocket = (websocketClass*)lua_newuserdata(L, sizeof(websocketClass));
	*webSocket = websocketClass{};

	webSocket->th = lua_newthread(L);
	webSocket->threadRef = lua_ref(L, -1);
	webSocket->webSocket = new ix::WebSocket();
	webSocket->webSocket->setUrl(url);
	lua_pop(L, 1);

	lua_getglobal(L, "Instance");
	lua_getfield(L, -1, "new");
	lua_pushstring(L, "BindableEvent");
	lua_pcall(L, 1, 1, 0);
	webSocket->onMessageRef = lua_ref(L, -1);
	lua_pop(L, 2);

	lua_getglobal(L, "Instance");
	lua_getfield(L, -1, "new");
	lua_pushstring(L, "BindableEvent");
	lua_pcall(L, 1, 1, 0);
	webSocket->onCloseRef = lua_ref(L, -1);
	lua_pop(L, 2);

	webSocket->webSocket->setOnMessageCallback(
		[webSocket](const ix::WebSocketMessagePtr& msg) -> void {
			if (msg->type == ix::WebSocketMessageType::Message) {
				webSocket->fireMessage(msg->str);
			}
			else if (msg->type == ix::WebSocketMessageType::Close || msg->type == ix::WebSocketMessageType::Error) {
				webSocket->fireClose();
			}

			return;
		}
	);

	lua_newtable(L);

	lua_pushstring(L, obfuscate_str("WebSocket"));
	lua_setfield(L, -2, obfuscate_str("__type"));

	lua_pushvalue(L, -2);
	lua_pushcclosure(L,
		[](lua_State* L) -> std::intptr_t {
			websocketClass* webSocket = reinterpret_cast<websocketClass*>(lua_touserdata(L, -10003));
			return webSocket->handleIndex(L);
		},
	obfuscate_str("__index"), 1);
	lua_setfield(L, -2, obfuscate_str("__index"));

	lua_pushvalue(L, -2);
	lua_pushcclosure(L,
		[](lua_State* L) -> std::intptr_t {
			websocketClass* webSocket = reinterpret_cast<websocketClass*>(lua_touserdata(L, -10003));
			return webSocket->handleNewIndex(L);
		},
		obfuscate_str("__newindex"), 1);
	lua_setfield(L, -2, obfuscate_str("__newindex"));

	lua_setmetatable(L, -2);

	webSocket->webSocket->connect(5);

	if (webSocket->webSocket->getReadyState() != ix::ReadyState::Open) {
		luaL_error(L, "WebSocket connection failed");
	}
		

	webSocket->connected = true;
	webSocket->webSocket->start();

	return 1;
}

/* registering */
static const luaL_Reg envFuncs[] = {
	{"connect", websocket_connect},
	{"Connect", websocket_connect},
	{NULL, NULL}
};

auto module::environment::createWebSockets(lua_State* L) -> void {
	lua_newtable(L);
	luaL_register(L, NULL, envFuncs);
	lua_setreadonly(L, -1, true);
	lua_setglobal(L, obfuscate_str("WebSocket"));
}