#include <sstream>
#include "render.h"
#include <kiero/kiero.h>
#include <roblox/miscellaneous/data/fonts.h>


DXGI_SWAP_CHAIN_DESC D11SwapChain;
IDXGISwapChain* D11GSwapChain = nullptr;

ID3D11Present D11Present = nullptr;
ID3D11ResizeBuffers D11Resize = nullptr;
ID3D11WindowProcess D11WindowProcess = nullptr;
ID3D11ResizeTarget D11ResizeTarget = nullptr;

ID3D11Device* D11Device = nullptr;
ID3D11DeviceContext* D11Context = nullptr;
ID3D11RenderTargetView* D11RenderTargetView;

ID3D11Texture2D* D11TextureBuffer = nullptr;

bool clearRender = false;
bool renderLoaded = false;
HWND currentWindow = nullptr;
RECT windowSize = { 0, 0, 0, 0 };
std::intptr_t windowWidth = 0, windowHeight = 0;

std::vector<module::render::baseType*> drawingVector{  };
std::vector<ImFont*> fonts{  };

namespace module {
	render* render::singleton{ nullptr };
	auto render::getSingleton() -> render* {
		if (singleton == nullptr)
			singleton = new render();

		return singleton;
	}

	auto __stdcall presentHook(IDXGISwapChain* pSwapChain, UINT syncInterval, UINT flag) -> HRESULT {
		if (!renderLoaded) {
			D11GSwapChain = pSwapChain;

			if (SUCCEEDED(D11GSwapChain->GetDevice(__uuidof(ID3D11Device), reinterpret_cast<void**>(&D11Device)))) {

				D11GSwapChain->GetDesc(&D11SwapChain);
				D11GSwapChain->GetDevice(__uuidof(ID3D11Device), reinterpret_cast<void**>(&D11Device));
				D11GSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<void**>(&D11TextureBuffer));

				currentWindow = FindWindowA(NULL, "Roblox");//D11SwapChain.OutputWindow;

				D11Device->GetImmediateContext(&D11Context);
				D11Device->CreateRenderTargetView(D11TextureBuffer, nullptr, &D11RenderTargetView);
				D11TextureBuffer->Release();

				ImGui::CreateContext();
				auto& io = ImGui::GetIO();
				ImFontConfig Config{};
				Config.OversampleH = 3;
				Config.OversampleV = 3;

				fonts.emplace_back(io.Fonts->AddFontFromMemoryCompressedTTF(seoge_ui_compressed_data, seoge_ui_compressed_size, 32.0f, &Config));
				fonts.emplace_back(io.Fonts->AddFontDefault(&Config));
				fonts.emplace_back(io.Fonts->AddFontFromMemoryCompressedTTF(ibm_plex_compressed_data, ibm_plex_compressed_size, 32.0f, &Config));
				fonts.emplace_back(io.Fonts->AddFontFromMemoryCompressedTTF(sometype_mono_compressed_data, sometype_mono_compressed_size, 32.0f, &Config));

				io.Fonts->TexGlyphPadding = 1;
				for (auto n = 0; n < io.Fonts->ConfigData.Size; n++) {
					auto* FontCfg = (ImFontConfig*)&io.Fonts->ConfigData[n];
					FontCfg->RasterizerMultiply = 1.0f;
					FontCfg->RasterizerFlags = 0;
				}

				io.Fonts->Build();

				ImGui_ImplDX11_Init(currentWindow, D11Device, D11Context);

				GetWindowRect(currentWindow, &windowSize);
				windowWidth = windowSize.right - windowSize.left;
				windowHeight = windowSize.bottom - windowSize.top;

				renderLoaded = true;
			}

			return D11Present(pSwapChain, syncInterval, flag);
		}

		GetWindowRect(currentWindow, &windowSize);
		int currentWindowWidth = windowSize.right - windowSize.left;
		int currentWindowHeight = windowSize.bottom - windowSize.top;

		if (currentWindowWidth != windowWidth || currentWindowHeight != windowHeight) {
			windowWidth = currentWindowWidth;
			windowHeight = currentWindowHeight;

			D3D11_VIEWPORT viewPort;
			viewPort.Width = windowWidth;
			viewPort.Height = windowHeight;
			viewPort.MinDepth = 0.0f;
			viewPort.MaxDepth = 1.0f;

			if (D11RenderTargetView) {
				D11RenderTargetView->Release();
				D11RenderTargetView = nullptr;
			}

			D11Context->RSSetViewports(1, &viewPort);
			pSwapChain->ResizeBuffers(0, windowWidth, windowHeight, DXGI_FORMAT_UNKNOWN, 0);
			ImGui_ImplDX11_InvalidateDeviceObjects();

			return D11Present(pSwapChain, syncInterval, flag);
		}

		if (clearRender) {
			clearRender = false;
			drawingVector.clear();
		}

		if (D11RenderTargetView == nullptr) {
			ID3D11Texture2D* pBackBuffer_1;
			pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer_1));
			D11Device->CreateRenderTargetView(pBackBuffer_1, nullptr, &D11RenderTargetView);
			pBackBuffer_1->Release();
		}

		ImGui_ImplDX11_NewFrame();
		ImGui::NewFrame();

		const auto renderList = ImGui::GetBackgroundDrawList();
		for (render::baseType* base : drawingVector) {
			if (!base->visible)
				continue;

			switch (base->type)
			{
				case render::Line:
				{
					render::lineType* lineData = reinterpret_cast<render::lineType*>(base);
					renderList->AddLine({ lineData->from.x, lineData->from.y }, { lineData->to.x, lineData->to.y }, ImColor(lineData->color.x, lineData->color.y, lineData->color.z, lineData->transparency), lineData->thickness);
					break;
				}
				case render::Circle:
				{
					render::circleType* circleData = reinterpret_cast<render::circleType*>(base);

					if (circleData->filled)
						renderList->AddCircleFilled({ circleData->position.x, circleData->position.y }, circleData->radius, ImColor(circleData->color.x, circleData->color.y, circleData->color.z, circleData->transparency), circleData->numsides);
					else
						renderList->AddCircle({ circleData->position.x, circleData->position.y }, circleData->radius, ImColor(circleData->color.x, circleData->color.y, circleData->color.z, circleData->transparency), circleData->numsides, circleData->thickness);

					break;
				}
				case render::Square:
				{
					render::squareType* squareData = reinterpret_cast<render::squareType*>(base);

					if (squareData->filled)
						renderList->AddRectFilled({ squareData->position.x, squareData->position.y }, { squareData->position.x + squareData->size.x, squareData->position.y + squareData->size.y }, ImColor(squareData->color.x, squareData->color.y, squareData->color.z, squareData->transparency));
					else
						renderList->AddRect({ squareData->position.x, squareData->position.y }, { squareData->position.x + squareData->size.x, squareData->position.y + squareData->size.y }, ImColor(squareData->color.x, squareData->color.y, squareData->color.z, squareData->transparency), 0, 0, squareData->thickness);

					break;
				}
				case render::Text:
				{
					render::textType* textData = reinterpret_cast<render::textType*>(base);

					ImFont* font = fonts.at(textData->font);

					if (font == nullptr)
						font = fonts.at(0);

					ImGui::PushFont(font);

					std::stringstream stream(std::string{ textData->text });
					std::string line;

					auto y = 0.0f;
					auto i = 0;

					while (std::getline(stream, line)) {
						const auto TextSize = font->CalcTextSizeA(textData->size, FLT_MAX, 0.0f, line.c_str());

						if (textData->center) {
							if (textData->outline) {
								renderList->AddText(
									font,
									textData->size,
									ImVec2(textData->position.x - TextSize.x / 2.0f + 1, textData->position.y + TextSize.y * i + 1),
									ImColor(ImVec4(textData->outlinecolor.x, textData->outlinecolor.y, textData->outlinecolor.z, textData->transparency)),
									line.c_str()
								);

								renderList->AddText(font, textData->size, ImVec2(textData->position.x - TextSize.x / 2.0f - 1, textData->position.y + TextSize.y * i - 1), ImColor(ImVec4(textData->outlinecolor.x, textData->outlinecolor.y, textData->outlinecolor.z, textData->transparency)), line.c_str());
								renderList->AddText(font, textData->size, ImVec2(textData->position.x - TextSize.x / 2.0f + 1, textData->position.y + TextSize.y * i - 1), ImColor(ImVec4(textData->outlinecolor.x, textData->outlinecolor.y, textData->outlinecolor.z, textData->transparency)), line.c_str());
								renderList->AddText(font, textData->size, ImVec2(textData->position.x - TextSize.x / 2.0f - 1, textData->position.y + TextSize.y * i + 1), ImColor(ImVec4(textData->outlinecolor.x, textData->outlinecolor.y, textData->outlinecolor.z, textData->transparency)), line.c_str());
							}

							renderList->AddText(font, textData->size, ImVec2(textData->position.x - TextSize.x / 2.0f, textData->position.y + TextSize.y * i), ImColor(ImVec4(textData->color.x, textData->color.y, textData->color.z, textData->transparency)), line.c_str());
						} else {
							if (textData->outline) {
								renderList->AddText(font, textData->size, ImVec2(textData->position.x + 1, textData->position.y + TextSize.y * i + 1), ImColor(ImVec4(textData->outlinecolor.x, textData->outlinecolor.y, textData->outlinecolor.z, textData->transparency)), line.c_str());
								renderList->AddText(font, textData->size, ImVec2(textData->position.x - 1, textData->position.y + TextSize.y * i - 1), ImColor(ImVec4(textData->outlinecolor.x, textData->outlinecolor.y, textData->outlinecolor.z, textData->transparency)), line.c_str());
								renderList->AddText(font, textData->size, ImVec2(textData->position.x + 1, textData->position.y + TextSize.y * i - 1), ImColor(ImVec4(textData->outlinecolor.x, textData->outlinecolor.y, textData->outlinecolor.z, textData->transparency)), line.c_str());
								renderList->AddText(font, textData->size, ImVec2(textData->position.x - 1, textData->position.y + TextSize.y * i + 1), ImColor(ImVec4(textData->outlinecolor.x, textData->outlinecolor.y, textData->outlinecolor.z, textData->transparency)), line.c_str());
							}

							renderList->AddText(font, textData->size, ImVec2(textData->position.x, textData->position.y + TextSize.y * i), ImColor(ImVec4(textData->color.x, textData->color.y, textData->color.z, textData->transparency)), line.c_str());
						}

						y = textData->position.y + TextSize.y * (i + 1);
						i++;
					}

					ImGui::PopFont();

					break;
				}
				case render::Triangle:
				{
					render::triangleType* triangleData = reinterpret_cast<render::triangleType*>(base);

					if (triangleData->filled)
						renderList->AddTriangleFilled({ triangleData->pointa.x, triangleData->pointa.y }, { triangleData->pointb.x, triangleData->pointb.y }, { triangleData->pointc.x, triangleData->pointc.y }, ImColor(triangleData->color.x, triangleData->color.y, triangleData->color.z, triangleData->transparency));
					else
						renderList->AddTriangle({ triangleData->pointa.x, triangleData->pointa.y }, { triangleData->pointb.x, triangleData->pointb.y }, { triangleData->pointc.x, triangleData->pointc.y }, ImColor(triangleData->color.x, triangleData->color.y, triangleData->color.z, triangleData->transparency), (float)triangleData->thickness);

					break;
				}
				case render::Quad:
				{
					render::quadType* quadData = reinterpret_cast<render::quadType*>(base);

					if (quadData->filled)
						renderList->AddQuadFilled({ quadData->pointa.x, quadData->pointa.y }, { quadData->pointb.x, quadData->pointb.y }, { quadData->pointc.x, quadData->pointc.y }, { quadData->pointd.x, quadData->pointd.y }, ImColor(quadData->color.x, quadData->color.y, quadData->color.z, quadData->transparency));
					else
						renderList->AddQuad({ quadData->pointa.x, quadData->pointa.y }, { quadData->pointb.x, quadData->pointb.y }, { quadData->pointc.x, quadData->pointc.y }, { quadData->pointd.x, quadData->pointd.y }, ImColor(quadData->color.x, quadData->color.y, quadData->color.z, quadData->transparency), (float)quadData->thickness);

					break;
				}
				case render::Image:
				{
					render::imageType* imageData = reinterpret_cast<render::imageType*>(base);

					if (imageData->rounding != 0)
						renderList->AddImageRounded((ImTextureID)imageData->data, imageData->position, { imageData->position.x + imageData->size.x, imageData->position.y + imageData->size.y }, ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f), ImColor(imageData->color.x, imageData->color.y, imageData->color.z, imageData->transparency), imageData->rounding);
					else
						renderList->AddImage((ImTextureID)imageData->data, imageData->position, { imageData->position.x + imageData->size.x, imageData->position.y + imageData->size.y }, ImVec2(0.0f, 0.0f), ImVec2(1.0f, 1.0f), ImColor(imageData->color.x, imageData->color.y, imageData->color.z, imageData->transparency));

					break;
				}
				default: {
					break;
				}
			}
		}
		

		ImGui::EndFrame();
		ImGui::Render();

		D11Context->OMSetRenderTargets(1, &D11RenderTargetView, NULL);
		ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

		if (D11RenderTargetView) {
			D11RenderTargetView->Release();
			D11RenderTargetView = nullptr;
		}

		return D11Present(pSwapChain, syncInterval, flag);
	}

	auto render::load() -> void {
		if (kiero::init(kiero::RenderType::D3D11) == kiero::Status::Success) {
			kiero::bind(8, reinterpret_cast<void**>(&D11Present), (void**)&presentHook);
		}
	}

	auto render::add(baseType* base) -> void {
		drawingVector.push_back(base);
	}

	auto render::remove(baseType* base) -> void {
		if (const auto iter = std::find(drawingVector.begin(), drawingVector.end(), base); iter != drawingVector.end()) {
			drawingVector.erase(iter);
			base->objectExist = false;
		}
	}

	auto render::getFonts() -> std::vector<ImFont*> {
		return fonts;
	}

	auto render::clear() -> void {
		clearRender = true;
		return;
	}
}