#include <roblox/exploit/execution/execution.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <utilities/utils/utils.h>
#include <lualib.h>
#include <thread>

#include "yield.h"

const auto utilities{ module::utils::getSingleton() };
const auto taskScheduler{ module::execution::getSingleton() };

namespace module {
	robloxYield* robloxYield::singleton{ nullptr };
	auto robloxYield::getSingleton() -> robloxYield* {
		if (singleton == nullptr)
			singleton = new robloxYield();

		return singleton;
	}

	auto threadFunc(const std::function<robloxYield::yieldReturn()>& yieldedFunction, lua_State* L) -> void {
		robloxYield::yieldReturn returnedFunc;

		try {
			returnedFunc = yieldedFunction();
		}
		catch (std::exception ex) {
			roblox::stdOut(3, ex.what());
			return;
		}

		/* this would be the resume function */
		taskScheduler->resume(L, returnedFunc(L));
	}

	auto robloxYield::haltExecution(lua_State* L, const std::function<yieldReturn()>& yieldedFunction)->std::intptr_t {
		lua_pushthread(L);
		lua_ref(L, -1);
		lua_pop(L, 1);

		std::thread(threadFunc, yieldedFunction, L).detach();

		L->base = L->top;
		L->status = LUA_YIELD;

		L->ci->flags |= 1;
		return -1;
	}
}