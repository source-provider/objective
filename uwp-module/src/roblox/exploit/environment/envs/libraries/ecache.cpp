#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <lualib.h>

using namespace module::roblox;

auto cache_invalidate(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));

	if (strcmp(luaL_typename(L, 1), obfuscate_str("Instance")) != LUA_OK){
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	std::intptr_t inst = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));

	lua_pushlightuserdata(L, reinterpret_cast<void*>(module::addresses::pushInstance));
	lua_gettable(L, LUA_REGISTRYINDEX);
	lua_pushlightuserdata(L, reinterpret_cast<void*>(inst));
	lua_pushnil(L);
	lua_settable(L, -3);

	return 0;
}

auto cache_iscached(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, luaL_checktype(L, 1, LUA_TUSERDATA););

	if (strcmp(luaL_typename(L, 1), obfuscate_str("Instance")) != LUA_OK) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	std::intptr_t inst = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));

	lua_pushlightuserdata(L, reinterpret_cast<void*>(module::addresses::pushInstance));
	lua_gettable(L, LUA_REGISTRYINDEX);
	lua_pushlightuserdata(L, reinterpret_cast<void*>(inst));
	lua_gettable(L, -2);

	lua_pushboolean(L, !lua_isnil(L, -1));

	return 1;
}

auto cache_replace(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
	checkType(L, 2, LUA_TUSERDATA);

	if (strcmp(luaL_typename(L, 1), obfuscate_str("Instance")) != LUA_OK) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	if (strcmp(luaL_typename(L, 2), obfuscate_str("Instance")) != LUA_OK) {
		luaL_typeerror(L, 2, "Instance");
		return 0;
	}

	std::intptr_t inst = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	lua_pushlightuserdata(L, reinterpret_cast<void*>(module::addresses::pushInstance));
	lua_gettable(L, LUA_REGISTRYINDEX);
	lua_pushlightuserdata(L, reinterpret_cast<void*>(inst));
	lua_pushvalue(L, 2);
	lua_settable(L, -3);

	return 0;
}

auto cloneref(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));

	void* originalUserdata = lua_touserdata(L, 1);
	std::uintptr_t returnedUserdata = *reinterpret_cast<std::uintptr_t*>(originalUserdata);

	lua_pushlightuserdata(L, reinterpret_cast<void*>(module::addresses::pushInstance));

	lua_rawget(L, -10000);
	lua_pushlightuserdata(L, reinterpret_cast<void*>(returnedUserdata));
	lua_rawget(L, -2);

	lua_pushlightuserdata(L, reinterpret_cast<void*>(returnedUserdata));
	lua_pushnil(L);
	lua_rawset(L, -4);

	pushInstance(L, originalUserdata);

	lua_pushlightuserdata(L, reinterpret_cast<void*>(returnedUserdata));
	lua_pushvalue(L, -3);
	lua_rawset(L, -5);

	return 1;
}

auto compareinstances(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
	checkType(L, 2, LUA_TUSERDATA);

	if (strcmp(luaL_typename(L, 1), obfuscate_str("Instance")) != LUA_OK) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	if (strcmp(luaL_typename(L, 2), obfuscate_str("Instance")) != LUA_OK) {
		luaL_typeerror(L, 2, "Instance");
		return 0;
	}

	int instance1 = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	int instance2 = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 2));

	lua_pushboolean(L, (instance1 == instance2));
	return 1;
}

/* registering */
static const luaL_Reg envFuncs[] = {
	{"invalidate", cache_invalidate},
	{"iscached", cache_iscached},
	{"replace", cache_replace},
	{NULL, NULL}
};

auto module::environment::createCache(lua_State* L) -> void {
	lua_newtable(L);
	luaL_register(L, NULL, envFuncs);
	lua_setreadonly(L, -1, true);
	lua_setglobal(L, obfuscate_str("cache"));

	lua_pushcclosure(L, cloneref, obfuscate_str("cloneref"), NULL);
	lua_setglobal(L, obfuscate_str("cloneref"));

	lua_pushcclosure(L, compareinstances, obfuscate_str("compareinstances"), NULL);
	lua_setglobal(L, obfuscate_str("compareinstances"));
}