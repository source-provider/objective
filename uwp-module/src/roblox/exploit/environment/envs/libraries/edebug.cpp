#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <lualib.h>
#include <dependencies/luau/vm/src/lfunc.h>

auto debug_getconstant(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2);

	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_typeerror(L, 1, "function or number");
		return 0;
	}

	const int index = luaL_checkinteger(L, 2);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	if (!index) {
		luaL_argerror(L, 2, "constant index starts at 1");
		return 0;
	}

	if (index > p->sizek) {
		luaL_argerror(L, 2, "constant index is out of range");
		return 0;
	}

	TValue* tval = &(k[index - 1]);

	if (tval->tt == LUA_TFUNCTION) {
		TValue* i_o = (L->top);
		setnilvalue(i_o);
		L->top++;
	}
	else {
		TValue* i_o = (L->top);
		i_o->value = tval->value;
		i_o->tt = tval->tt;
		L->top++;
	}


	return 1;
}

auto debug_getconstants(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1);

	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_typeerror(L, 1, "function or number");
		return 0;
	}

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	lua_newtable(L);

	for (int i = 0; i < p->sizek; i++) {
		TValue* tval = &(k[i]);

		if (tval->tt == LUA_TFUNCTION) {
			TValue* i_o = (L->top);
			setnilvalue(i_o);
			L->top++;
		}
		else {
			TValue* i_o = (L->top);
			i_o->value = tval->value;
			i_o->tt = tval->tt;
			L->top++;
		}

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_getinfo(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1);
	int level{};
	if (lua_isnumber(L, 1)) {
		level = lua_tointeger(L, 1);
		luaL_argcheck(L, level >= 0, 1, "level can't be negative");
	}
	else if (lua_isfunction(L, 1)) {
		level = -lua_gettop(L);
	}
	else {
		luaL_argerror(L, 1, "function or level expected");
		return 0;
	}

	lua_Debug ar;
	if (!lua_getinfo(L, level, "sluanf", &ar))
		luaL_argerror(L, 1, "invalid level");

	lua_newtable(L);

	lua_pushstring(L, ar.source);
	lua_setfield(L, -2, "source");

	lua_pushstring(L, ar.short_src);
	lua_setfield(L, -2, "short_src");

	lua_pushvalue(L, 1);
	lua_setfield(L, -2, "func");

	lua_pushstring(L, ar.what);
	lua_setfield(L, -2, "what");

	lua_pushinteger(L, ar.currentline);
	lua_setfield(L, -2, "currentline");

	lua_pushstring(L, ar.name);
	lua_setfield(L, -2, "name");

	lua_pushinteger(L, ar.nupvals);
	lua_setfield(L, -2, "nups");

	lua_pushinteger(L, ar.nparams);
	lua_setfield(L, -2, "numparams");

	lua_pushinteger(L, ar.isvararg);
	lua_setfield(L, -2, "is_vararg");

	return 1;
}

auto debug_getproto(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 3);
	luaL_checktype(L, 2, LUA_TNUMBER);

	bool active = luaL_optboolean(L, 3, false);

	if (lua_isnumber(L, 1)) {
		int level = lua_tointeger(L, 1);

		if (level >= L->ci - L->base_ci || level < 0) {
			luaL_argerror(L, 1, "stack level out of range");
		}

		lua_Debug ar;
		lua_getinfo(L, level, "f", &ar);

		if (clvalue(reinterpret_cast<CallInfo*>(L->ci - level)->func)->isC) {
			luaL_argerror(L, 1, "stack level to a cclosure, lclosure expected");
		}
	}
	else {
		lua_pushvalue(L, 1);
	}

	if (lua_isnumber(L, -1) == FALSE && lua_isfunction(L, -1) == FALSE) {
		luaL_argerror(L, 1, "function or level expected");
		return 0;
	}

	const auto function = clvalue(luaA_toobject(L, -1));

	if (!function->isC) {
		if (active) {
			lua_newtable(L);
		}

		const auto index = lua_tointeger(L, 2);

		if (index < 1 || index > function->l.p->sizep) {
			luaL_argerror(L, 2, "proto index out of range");
		}

		const auto proto = function->l.p->p[index - 1];

		setclvalue(L, L->top, luaF_newLclosure(L, proto->nups, function->env, proto));
		L->top++;

		if (active) {
			lua_rawseti(L, -2, 1);
		}
	}
	else {
		luaL_argerror(L, 1, "lclosure expected");
	}

	return 1;
}

auto debug_getprotos(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, luaL_checktype(L, 1, LUA_TFUNCTION););

	if (lua_iscfunction(L, -1)) {
		luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
		return 0;
	}

	Closure* closure = (Closure*)lua_topointer(L, -1);

	lua_newtable(L);

	Proto* main_proto = closure->l.p;

	for (int i = 0; i < main_proto->sizep; i++) {
		Proto* proto_data = main_proto->p[i];
		Closure* lclosure = luaF_newLclosure(L, proto_data->nups, closure->env, proto_data);

		setclvalue(L, L->top, lclosure);
		L->top++;

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_getstack(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 2);
	luaL_checktype(L, 1, LUA_TNUMBER);

	const auto level = lua_tointeger(L, 1);
	const auto index = luaL_optinteger(L, 2, -1);

	if (level >= L->ci - L->base_ci || level < 0) {
		luaL_argerror(L, 1, "level out of range");
	}

	const auto frame = reinterpret_cast<CallInfo*>(L->ci - level);
	const auto top = (frame->top - frame->base);

	if (clvalue(frame->func)->isC) {
		luaL_argerror(L, 1, "level points to a cclosure, lclosure expected");
	}

	if (index == -1) {
		lua_newtable(L);

		for (int i = 0; i < top; i++) {
			setobj2s(L, L->top, &frame->base[i]);
			L->top++;

			lua_rawseti(L, -2, i + 1);
		}
	}
	else {
		if (index < 1 || index > top) {
			luaL_argerror(L, 2, "stack index out of range");
		}

		setobj2s(L, L->top, &frame->base[index - 1]);
		L->top++;
	}
	return 1;
}

auto debug_getupvalue(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2);
	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_typeerror(L, 1, "function or number");
		return 0;
	}

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else
		lua_pushvalue(L, 1);

	const int index = luaL_checkinteger(L, 2);

	Closure* closure = (Closure*)lua_topointer(L, -1);
	TValue* upvalueTable = (TValue*)nullptr;

	if (!closure->isC)
		upvalueTable = closure->l.uprefs;
	else if (closure->isC)
		upvalueTable = closure->c.upvals;

	if (!index) {
		luaL_argerror(L, 2, "upvalue index starts at 1");
		return 0;
	}

	if (index > closure->nupvalues) {
		luaL_argerror(L, 2, "upvalue index is out of range");
		return 0;
	}

	TValue* upval = (&upvalueTable[index - 1]);
	TValue* top = L->top;

	top->value = upval->value;
	top->tt = upval->tt;
	L->top++;

	return 1;
}

auto debug_getupvalues(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1);
	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_typeerror(L, 1, "function or number");
		return 0;
	}

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);
	}

	Closure* closure = (Closure*)lua_topointer(L, -1);
	TValue* upvalueTable = (TValue*)nullptr;

	lua_newtable(L);


	if (!closure->isC)
		upvalueTable = closure->l.uprefs;
	else if (closure->isC)
		upvalueTable = closure->c.upvals;

	for (int i = 0; i < closure->nupvalues; i++) {
		TValue* upval = (&upvalueTable[i]);
		TValue* top = L->top;

		top->value = upval->value;
		top->tt = upval->tt;
		L->top++;

		lua_rawseti(L, -2, (i + 1));
	}

	return 1;
}

auto debug_setconstant(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 3, 3);

	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_typeerror(L, 1, "function or number");
		return 0;
	}

	const int index = luaL_checkinteger(L, 2);

	luaL_checkany(L, 3);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "stack points to a C closure, Lua function expected");
			return 0;
		}
	}
	else {
		lua_pushvalue(L, 1);

		if (lua_iscfunction(L, -1)) {
			luaL_argerror(L, 1, "Lua function expected");
			return 0;
		}
	}

	Closure* cl = (Closure*)lua_topointer(L, -1);
	Proto* p = cl->l.p;
	TValue* k = p->k;

	if (!index) {
		luaL_argerror(L, 2, "constant index starts at 1");
		return 0;
	}

	if (index > p->sizek) {
		luaL_argerror(L, 2, "constant index is out of range");
		return 0;
	}

	auto constant = &k[index - 1]; /* Lua-based indexing */

	if (constant->tt == LUA_TFUNCTION) {
		return 0;
	}

	const TValue* new_t = luaA_toobject(L, 3);
	constant->tt = new_t->tt;
	constant->value = new_t->value;

	return 0;
}

auto debug_setstack(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 3, 3);
	luaL_checktype(L, 1, LUA_TNUMBER);
	luaL_checktype(L, 2, LUA_TNUMBER);
	luaL_checkany(L, 3);

	const auto level = lua_tointeger(L, 1);
	const auto index = lua_tointeger(L, 2);

	if (level >= L->ci - L->base_ci || level < 0) {
		luaL_argerror(L, 1, "level out of range");
	}

	const auto frame = reinterpret_cast<CallInfo*>(L->ci - level);
	const auto top = (frame->top - frame->base);

	if (clvalue(frame->func)->isC) {
		luaL_argerror(L, 1, "level points to a cclosure, lclosure expected");
	}

	if (index < 1 || index > top) {
		luaL_argerror(L, 2, "stack index out of range");
	}

	setobj2s(L, &frame->base[index - 1], luaA_toobject(L, 3));
	return 0;
}

auto debug_setupvalue(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 3, 3);
	if (lua_isfunction(L, 1) == false && lua_isnumber(L, 1) == false) {
		luaL_typeerror(L, 1, "function or number");
		return 0;
	}


	const int index = luaL_checkinteger(L, 2);
	luaL_checkany(L, 3);

	if (lua_isnumber(L, 1)) {
		lua_Debug ar;

		if (!lua_getinfo(L, lua_tonumber(L, 1), "f", &ar)) {
			luaL_error(L, "level out of range");
			return 0;
		}
	}
	else
		lua_pushvalue(L, 1);

	Closure* closure = (Closure*)lua_topointer(L, -1);
	const TValue* value = luaA_toobject(L, 3);
	TValue* upvalue_table = (TValue*)nullptr;

	if (!closure->isC)
		upvalue_table = closure->l.uprefs;
	else if (closure->isC)
		upvalue_table = closure->c.upvals;

	if (!index) {
		luaL_argerror(L, 2, "upvalue index starts at 1");
		return 0;
	}

	if (index > closure->nupvalues) {
		luaL_argerror(L, 2, "upvalue index is out of range");
		return 0;
	}

	TValue* upvalue = (&upvalue_table[index - 1]);

	upvalue->value = value->value;
	upvalue->tt = value->tt;

	luaC_barrier(L, closure, value);
	lua_pushboolean(L, true);

	return 1;
}

auto getregistry(lua_State* L) -> int {
	luaL_stackcheck(L, 0, 0);
	lua_pushvalue(L, LUA_REGISTRYINDEX);
	return 1;
}

/* registering */
static const luaL_Reg envFuncs[] = {
	{"getconstant", debug_getconstant},
	{"getconstants", debug_getconstants},
	{"getinfo", debug_getinfo},
	{"getproto", debug_getproto},
	{"getprotos", debug_getprotos},
	{"getstack", debug_getstack},
	{"getupvalue", debug_getupvalue},
	{"getupvalues", debug_getupvalues},
	{"setconstant", debug_setconstant},
	{"setstack", debug_setstack},
	{"setupvalue", debug_setupvalue},
	{"getregistry", getregistry},
	{NULL, NULL}
};

auto module::environment::createDebug(lua_State* L) -> void {
	lua_newtable(L);

	registerExistingMember(L, "debug", "traceback");
	registerExistingMember(L, "debug", "info");
	registerExistingMember(L, "debug", "profilebegin");
	registerExistingMember(L, "debug", "profileend");
	registerExistingMember(L, "debug", "setmemorycategory");
	registerExistingMember(L, "debug", "getmemorycategory");
	registerExistingMember(L, "debug", "resetmemorycategory");
	registerExistingMember(L, "debug", "loadmodule");
	registerExistingMember(L, "debug", "dumpheap");

	luaL_register(L, NULL, envFuncs);
	lua_setreadonly(L, -1, true);
	lua_setglobal(L, obfuscate_str("debug"));

	lua_pushvalue(L, LUA_GLOBALSINDEX);
	luaL_register(L, NULL, envFuncs);
	lua_pop(L, 1);
}