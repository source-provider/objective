#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include "environment.h"
#include <lualib.h>
#include <sstream>

namespace module {
	environment* environment::singleton{ nullptr };
	auto environment::getSingleton() -> environment* {
		if (singleton == nullptr)
			singleton = new environment();

		return singleton;
	};

	auto environment::createEnvironment(lua_State* L) -> void {
		storage::getSingleton()->store<Table*>(obfuscate_str("robloxGlobalTable"), L->gt);
		luaL_sandboxthread(L);

		/* regular */
		this->createEnv(L);
		this->createClosure(L);
		this->createConsole(L);
		this->createFileSystem(L);
		this->createInput(L);
		this->createMetatable(L);
		this->createHttp(L);
		this->createOthers(L);

		/* libraries */
		this->createCache(L);
		this->createDebug(L);
		this->createDrawing(L);
		this->createCrypt(L);
		this->createWebSockets(L);
		this->createObjective(L);

		/* After register */
		this->createInit(L);
	};

	auto environment::getClassName(lua_State* L, std::intptr_t index) -> const char* {
		if (strcmp(luaL_typename(L, index), "Instance") != 0) {
			return "";
		}

		std::intptr_t instance = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, index));
		std::intptr_t descriptor = *reinterpret_cast<std::intptr_t*>(instance + module::instanceClassDescriptor);
		const char* classname = *reinterpret_cast<const char**>(descriptor + module::classDescriptorClassName);

		return classname;
	};

	auto environment::checkClassName(lua_State* L, std::intptr_t index, const char* className) -> void {
		luaL_checktype(L, index, LUA_TUSERDATA);
		if (strcmp(luaL_typename(L, index), "Instance") != 0) {
			luaL_argerror(L, index, "Instance");
		}

		std::intptr_t instance = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, index));
		std::intptr_t descriptor = *reinterpret_cast<std::intptr_t*>(instance + module::instanceClassDescriptor);
		const char* classname = *reinterpret_cast<const char**>(descriptor + module::classDescriptorClassName);

		if (strcmp(classname, className) != LUA_OK) {
			const char* fname = currfuncname(L);

			if (fname)
				luaL_error(L, "invalid argument #%d to '%s' (%s expected, got %s)", index, fname, className, classname);
			else
				luaL_error(L, "invalid argument #%d (%s expected, got %s)", index, className, classname);
		}
	};
}