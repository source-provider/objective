#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <roblox/exploit/classes/yield/yield.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <utilities/utils/utils.h>
#include <lualib.h>
#include <fstream>
#include <format>

const auto execution{ module::execution::getSingleton() };
const auto utilities{ module::utils::getSingleton() };
static std::vector<std::string> blacklisted = { ".exe", ".scr", ".bat", ".com", ".csh",".msi",".vb",".vbs",".vbe",".ws",".wsf",".wsh",".ps1",".py" };

auto __forceinline validatePath(lua_State* L, std::string fileName, bool checkExtension = true) -> void {
	if (checkExtension) {
		for (std::string& ext : blacklisted) {
			if (fileName.find(ext) != std::string::npos) {
				luaL_error(L, "extension not allowed");
			}	
		}
	}

	if (fileName.find("..") != std::string::npos) {
		luaL_error(L, "escaping directory not allowed");
	} else if (fileName.find("./") != std::string::npos) {
		luaL_error(L, "invalid path");
	} else if (fileName == ".") {
		luaL_error(L, "invalid path");
	}
}

auto readfile(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string fileName = lua_tostring(L, 1);
	validatePath(L, fileName);

	std::string filePath = (getDirectory() / fileName).string();
	if (!std::filesystem::is_regular_file(filePath)) {
		luaL_error(L, "file '%s' not exist", fileName.c_str());
	}
	
	std::ifstream file(filePath, std::ios::in | std::ios::binary);
	size_t fileSize = std::filesystem::file_size(filePath);

	if (!file.is_open()) {
		luaL_error(L, "unable to open '%s'", fileName.c_str());
		return 0;
	}
	
	std::string fileResult(fileSize, '\0');
	file.read(fileResult.data(), fileSize);
	file.close();

	lua_pushlstring(L, fileResult.c_str(), fileResult.size());
	return 1;
}

auto writefile(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TSTRING));
	checkType(L, 2, LUA_TSTRING);

	std::string fileName = lua_tostring(L, 1);
	std::string content = lua_tostring(L, 2);

	validatePath(L, fileName);
	std::string filePath = (getDirectory() / fileName).string();

	std::ofstream out(filePath, std::ios::out | std::ios::binary);

	if (!out.is_open()) {
		luaL_error(L, "unable to open '%s'", fileName.c_str());
		return 0;
	}

	out << content;
	out.close();

	return 1;
}

auto listfiles(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string directoryName = lua_tostring(L, 1);
	auto directoryLocation = getDirectory() / directoryName;
	validatePath(L, directoryName);

	if (!std::filesystem::exists(directoryLocation)) {
		luaL_error(L, "folder '%s' doesn't exist", directoryName.c_str());
		return 0;
	}

	lua_newtable(L);
	std::intptr_t idx = 0;

	for (auto& path : std::filesystem::directory_iterator(directoryLocation)) {
		std::string pathStr = path.path().string();
		utilities->replaceAll(pathStr, getDirectory().string(), obfuscate_str(""));
		lua_pushstring(L, pathStr.c_str());
		lua_rawseti(L, -2, ++idx);
	}

	return 1;
}

auto isfolder(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string directoryName = lua_tostring(L, 1);
	auto directoryLocation = getDirectory() / directoryName;
	
	if (directoryName.find("..") != std::string::npos) {
		luaL_error(L, "escaping directory not allowed");
	}
	else if (directoryName.find("./") != std::string::npos) {
		luaL_error(L, "invalid path");
	}
	else if (directoryName == ".") {
		luaL_error(L, "invalid path");
	}

	lua_pushboolean(L, std::filesystem::is_directory(directoryLocation));
	return 1;
}

auto isfile(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string fileName = lua_tostring(L, 1);
	auto fileLocation = getDirectory() / fileName;

	if (fileName.find("..") != std::string::npos) {
		luaL_error(L, "escaping directory not allowed");
	}
	else if (fileName.find("./") != std::string::npos) {
		luaL_error(L, "invalid path");
	}
	else if (fileName == ".") {
		luaL_error(L, "invalid path");
	}

	lua_pushboolean(L, std::filesystem::is_regular_file(fileLocation));
	return 1;
}

auto makefolder(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string folderName = lua_tostring(L, 1);
	auto folderLocation = getDirectory() / folderName;
	validatePath(L, folderName);

	std::filesystem::create_directories(folderLocation);
	return 0;
}

auto delfolder(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string directoryName = lua_tostring(L, 1);
	auto directoryLocation = getDirectory() / directoryName;
	validatePath(L, directoryName);

	if (!std::filesystem::exists(directoryLocation)) {
		luaL_error(L, "folder '%s' doesn't exist", directoryName.c_str());
		return 0;
	}

	std::filesystem::remove_all(directoryLocation);
	return 0;
}

auto delfile(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string fileName = lua_tostring(L, 1);
	auto fileLocation = getDirectory() / fileName;
	validatePath(L, fileName);

	if (!std::filesystem::is_regular_file(fileLocation)) {
		luaL_error(L, "folder '%s' doesn't exist", fileName.c_str());
		return 0;
	}

	std::filesystem::remove(fileLocation);
	return 0;
}

/* registering */
static const luaL_Reg envFuncs[] = {
	{"readfile", readfile},
	{"writefile", writefile},
	{"listfiles", listfiles},
	{"isfolder", isfolder},
	{"isfile", isfile},
	{"makefolder", makefolder},
	{"delfolder", delfolder},
	{"delfile", delfile},
	{NULL, NULL}
};

auto module::environment::createFileSystem(lua_State* L) -> void {
	lua_pushvalue(L, LUA_GLOBALSINDEX);
	luaL_register(L, NULL, envFuncs);
	lua_pop(L, 1);
}