#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <utilities/utils/utils.h>
#include <lualib.h>

const auto utils{ module::utils::getSingleton() };

#pragma region encryption shit
enum cryptModes
{
	//AES
	AES_CBC,
	AES_CFB,
	AES_CTR,
	AES_OFB,
	AES_GCM,
	AES_EAX,

	//Blowfish
	BF_CBC,
	BF_CFB,
	BF_OFB
};

enum hashModes
{
	//MD5
	MD5,

	//SHA1
	SHA1,

	//SHA2
	SHA224,
	SHA256,
	SHA384,
	SHA512,

	//SHA3
	SHA3_256,
	SHA3_384,
	SHA3_512,
};


std::map<std::string, cryptModes> cryptTranslationMap =
{
	//AES
	{ "aes-cbc", AES_CBC },
	{ "aes_cbc", AES_CBC },

	{ "aes-cfb", AES_CFB },
	{ "aes_cfb", AES_CFB },

	{ "aes-ctr", AES_CTR },
	{ "aes_ctr", AES_CTR },

	{ "aes-ofb", AES_OFB },
	{ "aes_ofb", AES_OFB },

	{ "aes-gcm", AES_GCM },
	{ "aes_gcm", AES_GCM },

	{ "aes-eax", AES_EAX },
	{ "aes_eax", AES_EAX },

	//Blowfish
	{ "blowfish-cbc", BF_CBC },
	{ "blowfish_cbc", BF_CBC },
	{ "bf-cbc", BF_CBC },
	{ "bf_cbc", BF_CBC },

	{ "blowfish-cfb", BF_CFB },
	{ "blowfish_cfb", BF_CFB },
	{ "bf-cfb", BF_CFB },
	{ "bf_cfb", BF_CFB },

	{ "blowfish-ofb", BF_OFB },
	{ "blowfish_ofb", BF_OFB },
	{ "bf-ofb", BF_OFB },
	{ "bf_ofb", BF_OFB },
};

std::map<std::string, hashModes> hashTranslationMap =
{
	//MD5
	{ "md5", MD5 },

	//SHA1
	{ "sha1", SHA1 },

	//SHA2
	{ "sha224", SHA224 },
	{ "sha256", SHA256 },
	{ "sha384", SHA384 },
	{ "sha512", SHA512 },

	//SHA3
	{ "sha3-256", SHA3_256 },
	{ "sha3_256", SHA3_256 },
	{ "sha3-384", SHA3_384 },
	{ "sha3_384", SHA3_384 },
	{ "sha3-512", SHA3_512 },
	{ "sha3_512", SHA3_512 },
};

template<typename T> 
auto __forceinline encryptWithAlgo(lua_State* L, const std::string& data, const std::string& keySize, const std::string& ivcStr) -> std::string {
	try
	{
		std::string encrypted;

		T encryptor;
		encryptor.SetKeyWithIV((BYTE*)keySize.c_str(), keySize.size(), (BYTE*)ivcStr.c_str(), ivcStr.length());

		CryptoPP::StringSource ss(data, true,
			new CryptoPP::StreamTransformationFilter(encryptor,
				new CryptoPP::StringSink(encrypted)
			)
		);

		return utils->base64Encode((unsigned char*)encrypted.c_str(), encrypted.size());
	}
	catch (CryptoPP::Exception& e)
	{
		luaL_error(L, e.what());
		return "";
	}
}

template<typename T>
auto __forceinline encryptAuthenticatedWithAlgo(lua_State* L, const std::string& data, const std::string& keySize, const std::string& ivcStr) -> std::string {
	try
	{
		std::string encrypted;

		T encryptor;
		encryptor.SetKeyWithIV((BYTE*)keySize.c_str(), keySize.size(), (BYTE*)ivcStr.c_str(), ivcStr.size());

		CryptoPP::AuthenticatedEncryptionFilter aef(encryptor,
			new CryptoPP::StringSink(encrypted)
		);

		aef.Put((const BYTE*)data.data(), data.size());
		aef.MessageEnd();

		return utils->base64Encode((unsigned char*)encrypted.c_str(), encrypted.size());
	}
	catch (CryptoPP::Exception& e)
	{
		luaL_error(L, e.what());
		return "";
	}
}

template<typename T>
auto __forceinline decryptWithAlgo(lua_State* L, const std::string& cipherText, const std::string& keyStr, const std::string& ivStr) -> std::string {
	try
	{
		std::string decrypted;

		T decryptor;
		decryptor.SetKeyWithIV((BYTE*)keyStr.c_str(), keyStr.size(), (BYTE*)ivStr.c_str(), ivStr.length());

		const auto base = utils->base64Decode(cipherText);

		CryptoPP::StringSource ss(base, true,
			new CryptoPP::StreamTransformationFilter(decryptor,
				new CryptoPP::StringSink(decrypted)
			)
		);

		return decrypted;
	}
	catch (CryptoPP::Exception& e)
	{
		luaL_error(L, e.what());
		return "";
	}
}

template<typename T>
auto __forceinline decryptAuthenticatedWithAlgo(lua_State* L, const std::string& cipherText, const std::string& keyStr, const std::string& ivStr) -> std::string {
	try
	{
		std::string decrypted;

		T decryptor;
		decryptor.SetKeyWithIV((BYTE*)keyStr.c_str(), keyStr.size(), (BYTE*)ivStr.c_str(), ivStr.size());

		const auto Base = utils->base64Decode(cipherText);

		CryptoPP::AuthenticatedDecryptionFilter adf(decryptor,
			new CryptoPP::StringSink(decrypted)
		);

		adf.Put((const BYTE*)Base.data(), Base.size());
		adf.MessageEnd();

		return decrypted;
	}
	catch (CryptoPP::Exception& e)
	{
		luaL_error(L, e.what());
		return "";
	}
}

#pragma endregion

auto base64encode(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string data = lua_tostring(L, 1);

	auto encoded = utils->base64Encode((unsigned char*)data.c_str(), data.size());
	lua_pushlstring(L, encoded.c_str(), (encoded.size() - 1));

	return 1;
}

auto base64decode(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string data = lua_tostring(L, 1);
	auto decoded = utils->base64Decode(data);

	lua_pushlstring(L, decoded.c_str(), decoded.size());
	return 1;
}

auto crypt_encrypt(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TSTRING));
	checkType(L, 2, LUA_TSTRING);

	std::string data = lua_tostring(L, 1, NULL);
	std::string key = lua_tostring(L, 2, NULL);

	CryptoPP::AutoSeededRandomPool prng;
	BYTE iv[12];
	prng.GenerateBlock(iv, 12);

	BYTE derivedKey[32];
	CryptoPP::PKCS5_PBKDF2_HMAC<CryptoPP::SHA384> kdf;
	kdf.DeriveKey(derivedKey, 32, 0, (BYTE*)key.c_str(), key.size(), NULL, 0, 10000);

	auto encrypted = encryptAuthenticatedWithAlgo<CryptoPP::GCM<CryptoPP::AES>::Encryption>(L,
		std::string(data.c_str(), data.size()),
		std::string((const char*)derivedKey, 32),
		std::string((const char*)iv, 12));

	encrypted += "|" + utils->base64Encode(iv, 12);
	encrypted = utils->base64Encode((BYTE*)encrypted.data(), encrypted.size());

	lua_pushlstring(L, encrypted.c_str(), encrypted.size());
	return 1;
}

auto crypt_decrypt(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TSTRING));
	checkType(L, 2, LUA_TSTRING);

	std::string data = lua_tostring(L, 1, NULL);
	std::string key = lua_tostring(L, 2, NULL);

	BYTE derivedKey[32];
	CryptoPP::PKCS5_PBKDF2_HMAC<CryptoPP::SHA384> kdf;
	kdf.DeriveKey(derivedKey, 32, 0, (BYTE*)key.c_str(), key.size(), NULL, 0, 10000);

	std::vector<std::string> split;
	utils->splitString(utils->base64Decode(data), "|", split);

	if (split.size() != 2) {
		luaL_argerror(L, 1, "Invalid encrypted string specified");
		return 0;
	}

	auto decrypted = decryptAuthenticatedWithAlgo<CryptoPP::GCM<CryptoPP::AES>::Decryption>(L,
		split.at(0),
		std::string((const char*)derivedKey, 32),
		utils->base64Decode(split.at(1)));


	lua_pushlstring(L, decrypted.c_str(), decrypted.size());
	return 1;
}

auto crypt_generatebytes(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TNUMBER));
	int len = lua_tointeger(L, 1);

	if (len > 1024) {
		luaL_argerror(L, 1, "exceeded maximum size (1024)");
		return 0;
	}

	if (len < 0) {
		luaL_argerror(L, 1, "negative size specified");
		return 0;
	}

	std::string data = utils->randomString(len);

	auto encoded = utils->base64Encode((unsigned char*)data.c_str(), data.size());
	lua_pushlstring(L, encoded.c_str(), encoded.size());

	return 1;
}

auto crypt_generatekey(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);
	std::string data = utils->randomString(32);

	auto encoded = utils->base64Encode((unsigned char*)data.c_str(), data.size());
	lua_pushlstring(L, encoded.c_str(), encoded.size());

	return 1;
}

auto crypt_hash(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string data = luaL_checklstring(L, 1, NULL);

	auto hash = utils->hashWithAlgo<CryptoPP::SHA384>(data);
	lua_pushlstring(L, hash.c_str(), hash.size());
	return 1;
}

auto crypt_random(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TNUMBER));
	const auto size = lua_tointeger(L, 1);

	if (size > 1024) {
		luaL_argerror(L, 1, "exceeded maximum size (1024)");
		return 0;
	}

	if (size < 0) {
		luaL_argerror(L, 1, "negative size specified");
		return 0;
	}

	CryptoPP::AutoSeededRandomPool prng;
	auto alloc = (BYTE*) operator new(size);
	prng.GenerateBlock(alloc, size);
	lua_pushlstring(L, (const char*)alloc, size);

	delete alloc;

	return 1;
}

auto crypt_derive(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TSTRING));
	checkType(L, 2, LUA_TNUMBER);
	std::string data = lua_tostring(L, 1);
	const auto size = lua_tointeger(L, 2);

	if (size > 1024) {
		luaL_argerror(L, 1, "exceeded maximum size (1024)");
		return 0;
	}

	if (size < 0) {
		luaL_argerror(L, 1, "negative size specified");
		return 0;
	}

	auto alloc = (BYTE*) operator new(size);
	CryptoPP::PKCS5_PBKDF2_HMAC<CryptoPP::SHA384> KDF;
	KDF.DeriveKey(alloc, size, 0, (BYTE*)data.c_str(), data.size(), NULL, 0, 10000);

	lua_pushlstring(L, (const char*)alloc, size);

	delete alloc;
	return 1;
}

auto crypt_custom_encrypt(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 4, 4, checkType(L, 1, LUA_TSTRING));
	checkType(L, 2, LUA_TSTRING);
	checkType(L, 3, LUA_TSTRING);
	checkType(L, 4, LUA_TSTRING);


	std::string algo = lua_tostring(L, 1);
	std::string data = lua_tostring(L, 2);
	std::string keySize = lua_tostring(L, 3);
	std::string ivcStr = lua_tostring(L, 4);

	std::transform(algo.begin(), algo.end(), algo.begin(), tolower);

	if (!cryptTranslationMap.count(algo)) {
		luaL_argerror(L, 1, "non-existant algorithm");
		return 0;
	}

	const auto ralgo = cryptTranslationMap[algo];
	std::string result;

	if (ralgo == AES_CBC) {
		result = encryptWithAlgo<CryptoPP::CBC_Mode<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_CFB) {
		result = encryptWithAlgo<CryptoPP::CBC_Mode<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_CTR) {
		result = encryptWithAlgo<CryptoPP::CTR_Mode<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_OFB) {
		result = encryptWithAlgo<CryptoPP::OFB_Mode<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_GCM) {
		result = encryptAuthenticatedWithAlgo<CryptoPP::GCM<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_EAX) {
		result = encryptAuthenticatedWithAlgo<CryptoPP::EAX<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == BF_CBC) {
		result = encryptWithAlgo<CryptoPP::CBC_Mode<CryptoPP::Blowfish>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == BF_CFB) {
		result = encryptWithAlgo<CryptoPP::CFB_Mode<CryptoPP::Blowfish>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == BF_OFB) {
		result = encryptWithAlgo<CryptoPP::OFB_Mode<CryptoPP::Blowfish>::Encryption>(L, data, keySize, ivcStr);
	}
	else {
		luaL_argerror(L, 1, "non-existant algorithm");
		return 0;
	}

	lua_pushlstring(L, result.c_str(), result.size());
	return 1;
};

auto crypt_custom_decrypt(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 4, 4, checkType(L, 1, LUA_TSTRING));
	checkType(L, 2, LUA_TSTRING);
	checkType(L, 3, LUA_TSTRING);
	checkType(L, 4, LUA_TSTRING);


	std::string algo = lua_tostring(L, 1);
	std::string data = lua_tostring(L, 2);
	std::string keySize = lua_tostring(L, 3);
	std::string ivcStr = lua_tostring(L, 4);

	std::transform(algo.begin(), algo.end(), algo.begin(), tolower);

	if (!cryptTranslationMap.count(algo)) {
		luaL_argerror(L, 1, "non-existant algorithm");
		return 0;
	}

	const auto ralgo = cryptTranslationMap[algo];
	std::string result;

	if (ralgo == AES_CBC) {
		result = decryptWithAlgo<CryptoPP::CBC_Mode<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_CFB) {
		result = decryptWithAlgo<CryptoPP::CBC_Mode<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_CTR) {
		result = decryptWithAlgo<CryptoPP::CTR_Mode<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_OFB) {
		result = decryptWithAlgo<CryptoPP::OFB_Mode<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_GCM) {
		result = decryptAuthenticatedWithAlgo<CryptoPP::GCM<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == AES_EAX) {
		result = decryptAuthenticatedWithAlgo<CryptoPP::EAX<CryptoPP::AES>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == BF_CBC) {
		result = decryptWithAlgo<CryptoPP::CBC_Mode<CryptoPP::Blowfish>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == BF_CFB) {
		result = decryptWithAlgo<CryptoPP::CFB_Mode<CryptoPP::Blowfish>::Encryption>(L, data, keySize, ivcStr);
	}
	else if (ralgo == BF_OFB) {
		result = decryptWithAlgo<CryptoPP::OFB_Mode<CryptoPP::Blowfish>::Encryption>(L, data, keySize, ivcStr);
	}
	else {
		luaL_argerror(L, 1, "non-existant algorithm");
		return 0;
	}

	lua_pushlstring(L, result.c_str(), result.size());
	return 1;
};

auto crypt_custom_hash(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TSTRING));
	checkType(L, 1, LUA_TSTRING);

	std::string algo = lua_tostring(L, 1);
	std::string data = lua_tostring(L, 2);

	std::transform(algo.begin(), algo.end(), algo.begin(), tolower);
	if (!hashTranslationMap.count(algo))
	{
		luaL_argerror(L, 1, "non-existant hash algorithm");
		return 0;
	}

	const auto ralgo = hashTranslationMap[algo];
	std::string hash;

	//This is intentional - blame Themida not supporting jump tables.
	if (ralgo == MD5) {
		hash = utils->hashWithAlgo<CryptoPP::Weak::MD5>(data);
	}
	else if (ralgo == SHA1) {
		hash = utils->hashWithAlgo<CryptoPP::SHA1>(data);
	}
	else if (ralgo == SHA224) {
		hash = utils->hashWithAlgo<CryptoPP::SHA224>(data);
	}
	else if (ralgo == SHA256) {
		hash = utils->hashWithAlgo<CryptoPP::SHA256>(data);
	}
	else if (ralgo == SHA384) {
		hash = utils->hashWithAlgo<CryptoPP::SHA384>(data);
	}
	else if (ralgo == SHA512) {
		hash = utils->hashWithAlgo<CryptoPP::SHA512>(data);
	}
	else if (ralgo == SHA3_256) {
		hash = utils->hashWithAlgo<CryptoPP::SHA3_256>(data);
	}
	else if (ralgo == SHA3_384) {
		hash = utils->hashWithAlgo<CryptoPP::SHA3_384>(data);
	}
	else if (ralgo == SHA3_512) {
		hash = utils->hashWithAlgo<CryptoPP::SHA3_512>(data);
	}
	else {
		luaL_argerror(L, 1, "non-existant hash algorithm");
		return 0;
	}

	lua_pushlstring(L, hash.c_str(), hash.size());
	return 1;
};

/* registering */
static const luaL_Reg envFuncs[] = {
	{"base64encode", base64encode},
	{"base64decode", base64decode},
	{"base64_encode", base64encode},
	{"base64_decode", base64decode},

	{"encrypt", crypt_encrypt},
	{"decrypt", crypt_decrypt},
	{"generatebytes", crypt_generatebytes},
	{"generatekey", crypt_generatekey},
	{"hash", crypt_hash},
	{"random", crypt_random},
	{"derive", crypt_derive},
	{NULL, NULL}
};

auto module::environment::createCrypt(lua_State* L) -> void {
	/* crypt */
	lua_newtable(L);
	luaL_register(L, NULL, envFuncs);

	/* base64 library */
	lua_newtable(L);
	lua_pushcclosure(L, base64encode, obfuscate_str("crypt.base64.encode"), NULL);
	lua_setfield(L, -2, obfuscate_str("encode"));

	lua_pushcclosure(L, base64decode, obfuscate_str("crypt.base64.decode"), NULL);
	lua_setfield(L, -2, obfuscate_str("decode"));

	lua_setreadonly(L, -1, true);
	lua_setfield(L, -2, obfuscate_str("base64"));

	/* end of base64 */

	/* custom */
	lua_newtable(L);

	lua_pushcclosure(L, crypt_custom_hash, obfuscate_str("crypt.custom.hash"), NULL);
	lua_setfield(L, -2, obfuscate_str("hash"));

	lua_pushcclosure(L, crypt_custom_encrypt, obfuscate_str("crypt.custom.encrypt"), NULL);
	lua_setfield(L, -2, obfuscate_str("hash"));

	lua_pushcclosure(L, crypt_custom_decrypt, obfuscate_str("crypt.custom.decrypt"), NULL);
	lua_setfield(L, -2, obfuscate_str("hash"));

	lua_setreadonly(L, -1, true);
	lua_setfield(L, -2, obfuscate_str("custom"));
	/* end of custom */


	lua_setreadonly(L, -1, true);
	lua_setglobal(L, obfuscate_str("crypt"));

	lua_pushcclosure(L, base64encode, obfuscate_str("base64_encode"), NULL);
	lua_setglobal(L, obfuscate_str("base64_encode"));

	lua_pushcclosure(L, base64decode, obfuscate_str("base64_decode"), NULL);
	lua_setglobal(L, obfuscate_str("base64_decode"));

	/* base 64 */
	lua_newtable(L);
	
	lua_pushcclosure(L, base64encode, obfuscate_str("base64.encode"), NULL);
	lua_setfield(L, -2, obfuscate_str("encode"));

	lua_pushcclosure(L, base64decode, obfuscate_str("base64.decode"), NULL);
	lua_setfield(L, -2, obfuscate_str("decode"));

	lua_setreadonly(L, -1, true);
	lua_setglobal(L, obfuscate_str("base64"));
}