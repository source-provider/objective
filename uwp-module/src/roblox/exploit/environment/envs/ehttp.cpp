#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <roblox/exploit/classes/yield/yield.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <cpr/HttpStatus.hpp>
#include <cpr/cpr.h>
#include <lualib.h>

const auto yielder{ module::robloxYield::getSingleton() };

enum requestMethods
{
	H_GET,
	H_HEAD,
	H_POST,
	H_PUT,
	H_DELETE,
	H_OPTIONS
};

std::map<std::string, requestMethods> requestMethodMap =
{
	{ "get", H_GET },
	{ "head", H_HEAD },
	{ "post", H_POST },
	{ "put", H_PUT },
	{ "delete", H_DELETE },
	{ "options", H_OPTIONS }
};

std::map<uint32_t, std::string> httpCache = {};
auto module::environment::httpget(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 3, checkType(L, 1, LUA_TUSERDATA));
	checkType(L, 2, LUA_TSTRING);

	std::string url = lua_tostring(L, 2);
	bool blockCache = luaL_optboolean(L, 3, false);

	if (url.find("http") != 0) {
		luaL_error(L, obfuscate_str("Invalid protocol specified (expected 'http://' or 'https://')"));
		return 0;
	}

	uint32_t hash = FNV1A(url.c_str());
	std::string data = httpCache[hash];

	if (httpCache[hash].length() != 0 && blockCache == false) {
		lua_pushlstring(L, data.c_str(), data.size());
		return 1;
	}

	return yielder->haltExecution(L,
		[url, hash]() -> auto {
			auto result = cpr::Get(cpr::Url{ url }, cpr::Header{ {"User-Agent", "Roblox/WinInet"} });

			return [result, url, hash](lua_State* L) -> std::intptr_t {
				if (result.status_code == 0) {
					auto err = "Http Error " + std::to_string(result.status_code) + " - " + result.error.message;
					luaL_error(L, err.c_str());
					return 0;
				}

				if (HttpStatus::IsError(result.status_code)) {
					auto err = "Http Error " + std::to_string(result.status_code) + " - " + HttpStatus::ReasonPhrase(result.status_code);
					luaL_error(L, err.c_str());
					return 0;
				}

				httpCache[hash] = result.text;

				lua_pushlstring(L, result.text.c_str(), result.text.size());
				return 1;
			};
		}
	);
}

auto module::environment::httppost(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 4, 4, checkType(L, 1, LUA_TUSERDATA));
	checkType(L, 2, LUA_TSTRING);
	checkType(L, 3, LUA_TSTRING);
	checkType(L, 4, LUA_TSTRING);

	std::string url = lua_tostring(L, 2);
	std::string data = lua_tostring(L, 3);
	std::string contentType = lua_tostring(L, 4);

	if (url.find("http") != 0) {
		luaL_error(L, obfuscate_str("Invalid protocol specified (expected 'http://' or 'https://')"));
		return 0;
	}

	return yielder->haltExecution(L,
		[url, data, contentType]() -> auto {
			auto result = cpr::Post(cpr::Url{ url },
				cpr::Header{ {"User-Agent", "Roblox/WinInet"} },
				cpr::Body{ data },
				cpr::Header{ { "Content-Type", contentType} });

			return [result](lua_State* L) -> std::intptr_t {
				if (result.status_code == 0) {
					auto err = "Http Error " + std::to_string(result.status_code) + " - " + result.error.message;
					luaL_error(L, err.c_str());
					return 0;
				}

				if (HttpStatus::IsError(result.status_code)) {
					auto err = "Http Error " + std::to_string(result.status_code) + " - " + HttpStatus::ReasonPhrase(result.status_code);
					luaL_error(L, err.c_str());
					return 0;
				}

				lua_pushlstring(L, result.text.c_str(), result.text.size());
				return 1;
			};
		}
	);
}

auto http_request(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TTABLE));

	lua_getfield(L, 1, obfuscate_str("Url"));
	if (lua_type(L, -1) != LUA_TSTRING) {
		luaL_error(L, obfuscate_str("Invalid or no 'Url' field specified in request table"));
		return 0;
	}

	std::string url = lua_tostring(L, -1);

	if (url.find("http") != 0) {
		luaL_error(L, obfuscate_str("Invalid protocol specified (expected 'http://' or 'https://')"));
		return 0;
	}

	lua_pop(L, 1);

	auto method = H_GET;
	lua_getfield(L, 1, "Method");
	if (lua_type(L, -1) == LUA_TSTRING) {
		std::string methods = luaL_checkstring(L, -1);
		std::transform(methods.begin(), methods.end(), methods.begin(), tolower);

		if (!requestMethodMap.count(methods)) {
			luaL_error(L, obfuscate_str("Request type '%s' is not a valid http request type."), methods.c_str());
			return 0;
		}

		method = requestMethodMap[methods];
	}
	lua_pop(L, 1);

	cpr::Header headers;

	lua_getfield(L, 1, "Headers");
	if (lua_type(L, -1) == LUA_TTABLE) {
		lua_pushnil(L);

		while (lua_next(L, -2)) {
			if (lua_type(L, -2) != LUA_TSTRING || lua_type(L, -1) != LUA_TSTRING) {
				luaL_error(L, obfuscate_str("'Headers' table must contain string keys/values."));
				return 0;
			}

			std::string headerKey = luaL_checkstring(L, -2);
			auto headerCopy = std::string(headerKey);
			std::transform(headerKey.begin(), headerKey.end(), headerKey.begin(), tolower);

			if (headerCopy == "content-length") {
				luaL_error(L, obfuscate_str("Headers: 'Content-Length' header cannot be overwritten."));
				return 0;
			}

			std::string headerValue = luaL_checkstring(L, -1);
			headers.insert({ headerKey, headerValue });
			lua_pop(L, 1);
		}
	}
	lua_pop(L, 1);

	cpr::Cookies cookies;
	lua_getfield(L, 1, "Cookies");

	if (lua_type(L, -1) == LUA_TTABLE) {
		std::map<std::string, std::string> rcookies;
		lua_pushnil(L);

		while (lua_next(L, -2)) {
			if (lua_type(L, -2) != LUA_TSTRING || lua_type(L, -1) != LUA_TSTRING)
			{
				luaL_error(L, obfuscate_str("'Cookies' table must contain string keys/values."));
				return 0;
			}

			std::string cookieKey = luaL_checkstring(L, -2);
			std::string cookieValue = luaL_checkstring(L, -1);

			rcookies[cookieKey] = cookieValue;
			lua_pop(L, 1);
		}

		cookies = rcookies;
	}

	lua_pop(L, 1);

	auto hasUserAgent = false;
	for (auto& header : headers) {
		auto headerName = header.first;
		std::transform(headerName.begin(), headerName.end(), headerName.begin(), tolower);

		if (headerName == "user-agent")
			hasUserAgent = true;
	}

	if (!hasUserAgent) {
		headers.insert({ "User-Agent", cExploitName });
	}

	std::string body;
	lua_getfield(L, 1, "Body");
	if (lua_type(L, -1) == LUA_TTABLE) {
		if (method == H_GET || method == H_HEAD) {
			luaL_error(L, obfuscate_str("'Body' cannot be present in GET or HEAD requests."));
			return 0;
		}

		size_t bodySize;
		const auto bodyCstr = luaL_checklstring(L, -1, &bodySize);
		body = std::string(bodyCstr, bodySize);
	}
	lua_pop(L, 1);

	return yielder->haltExecution(L,
		[method, url, headers, cookies, body]() -> auto {
			cpr::Response response;

			switch (method)
			{
				case H_GET:
				{
					response = cpr::Get(
						cpr::Url{ url },
						cookies,
						headers
					);

					break;
				}

				case H_HEAD:
				{
					response = cpr::Head(
						cpr::Url{ url },
						cookies,
						headers
					);

					break;
				}

				case H_POST:
				{
					response = cpr::Post(
						cpr::Url{ url },
						cpr::Body{ body },
						cookies,
						headers
					);

					break;
				}

				case H_PUT:
				{
					response = cpr::Put(
						cpr::Url{ url },
						cpr::Body{ body },
						cookies,
						headers
					);

					break;
				}

				case H_DELETE:
				{
					response = cpr::Delete(
						cpr::Url{ url },
						cpr::Body{ body },
						cookies,
						headers
					);

					break;
				}

				case H_OPTIONS:
				{
					response = cpr::Options(
						cpr::Url{ url },
						cpr::Body{ body },
						cookies,
						headers
					);

					break;
				}

				default:
				{
					throw std::exception(obfuscate_str("invalid request type"));
				}
			}

			return [response](lua_State* L) -> std::intptr_t {
				lua_newtable(L);

				lua_pushboolean(L, HttpStatus::IsSuccessful(response.status_code));
				lua_setfield(L, -2, obfuscate_str("Success"));

				lua_pushinteger(L, response.status_code);
				lua_setfield(L, -2, obfuscate_str("StatusCode"));

				std::string phrase = HttpStatus::ReasonPhrase(response.status_code);
				lua_pushlstring(L, phrase.c_str(), phrase.size());
				lua_setfield(L, -2, obfuscate_str("StatusMessage"));

				lua_newtable(L);

				for (auto& header : response.header) {
					lua_pushlstring(L, header.first.c_str(), header.first.size());
					lua_pushlstring(L, header.second.c_str(), header.second.size());

					lua_settable(L, -3);
				}

				lua_setfield(L, -2, obfuscate_str("Headers"));

				lua_newtable(L);

				for (auto& cookie : response.cookies.map_) {
					lua_pushlstring(L, cookie.first.c_str(), cookie.first.size());
					lua_pushlstring(L, cookie.second.c_str(), cookie.second.size());

					lua_settable(L, -3);
				}

				lua_setfield(L, -2, obfuscate_str("Cookies"));

				lua_pushlstring(L, response.text.c_str(), response.text.size());
				lua_setfield(L, -2, obfuscate_str("Body"));

				return 1;
			};
		}
	);
}

/* registering */
static const luaL_Reg envFuncs[] = {
	{"httpget", module::environment::httpget},
	{"HttpGet", module::environment::httpget},
	{"httpgetasync", module::environment::httpget},
	{"HttpGetAsync", module::environment::httpget},

	{"httppost", module::environment::httppost},
	{"HttpPost", module::environment::httppost},
	{"httppostasync", module::environment::httppost},
	{"HttpPostAsync", module::environment::httppost},

	{"http_request", http_request},
	{"request", http_request},

	{NULL, NULL}
};

auto module::environment::createHttp(lua_State* L) -> void {
	lua_pushvalue(L, LUA_GLOBALSINDEX);
	luaL_register(L, NULL, envFuncs);
	lua_pop(L, 1);

	lua_newtable(L);
	lua_pushcclosure(L, http_request, obfuscate_str("http.request"), 0);
	lua_setfield(L, -2, obfuscate_str("request"));
	lua_setreadonly(L, -1, true);
	lua_setglobal(L, obfuscate_str("http"));
}