#pragma once
#include <ImGUI/imgui.h>
#include <ImGUI/imgui_internal.h>
#include <ImGUI/imgui_impl_dx11.h>
#include <ImGUI/imstb_truetype.h>
#include <ImGUI/TextEditor.h>
#include <ImGUI/imgui_impl_dx11.h>
#include <ImGUI/imgui_internal.h>
#include <D3D11.h>
#include <d3dcompiler.h>

typedef HRESULT(__stdcall* ID3D11Present)(IDXGISwapChain* SwapChain, UINT SyncInterval, UINT Flags);
typedef HRESULT(__stdcall* ID3D11ResizeBuffers)(IDXGISwapChain* SwapChain, UINT BufferCount, UINT Width, UINT Height, DXGI_FORMAT NewFormat, UINT SwapChainFlags);
typedef HRESULT(__stdcall* ID3D11ResizeTarget)(const DXGI_MODE_DESC* pNewTargetParameter);
typedef LRESULT(__stdcall* ID3D11WindowProcess)(HWND, UINT, WPARAM, LPARAM);
typedef HRESULT(__stdcall* presentHookT)(IDXGISwapChain*, UINT, UINT);

namespace module {
	class render {
	private:
		static render* singleton;
	public:
		enum renderObjectType {
			Line,
			Circle,
			Square,
			Text,
			Triangle,
			Quad,
			Image
		};

		class baseType {
		public:
			bool visible = false;
			bool objectExist = true;
			std::intptr_t zindex = 1;
			renderObjectType type;
		};

		class lineType : public baseType {
		public:
			ImVec2 from = { 0.f, 0.f };
			ImVec2 to = { 0.f, 0.f };
			ImVec4 color = { 0.f, 0.f, 0.f, 0.f };

			std::intptr_t thickness = 16;
			float transparency = 1.f;
		};

		class circleType : public baseType {
		public:
			ImVec2 position = { 0.f, 0.f };
			ImVec4 color = { 0.f, 0.f, 0.f, 0.f };

			bool filled = false;
			float transparency = 1.f;

			std::intptr_t radius = 0;
			std::intptr_t thickness = 15;
			std::intptr_t numsides = 250;
		};

		class squareType : public baseType {
		public:
			ImVec2 position = { 0.f, 0.f };
			ImVec2 size = { 0.f, 0.f };
			ImVec4 color = { 0.f, 0.f, 0.f, 0.f };

			std::intptr_t thickness = 16;
			bool filled = false;
			float transparency = 1.f;
		};

		class textType : public baseType {
		public:
			char text[512];

			ImVec2 position = { 0.f, 0.f };
			ImVec4 color = { 0.f, 0.f, 0.f, 0.f };
			ImVec4 outlinecolor = { 0.f, 0.f, 0.f, 0.f };

			std::intptr_t font = 0;
			bool center = false;
			bool outline = false;
			float size = 16;
			float transparency = 1.f;
			ImVec2 textbounds = { 0.f, 16.f };
		};


		class triangleType : public baseType {
		public:
			ImVec2 pointa = { 0.f, 0.f };
			ImVec2 pointb = { 0.f, 0.f };
			ImVec2 pointc = { 0.f, 0.f };

			ImVec4 color = { 0.f, 0.f, 0.f, 0.f };

			std::intptr_t thickness = 15;
			bool filled = false;
			float transparency = 1.f;
		};

		class quadType : public baseType {
		public:
			ImVec2 pointa = { 0.f, 0.f };
			ImVec2 pointb = { 0.f, 0.f };
			ImVec2 pointc = { 0.f, 0.f };
			ImVec2 pointd = { 0.f, 0.f };

			ImVec4 color = { 0.f, 0.f, 0.f, 0.f };

			std::intptr_t thickness = 16;
			bool filled = false;
			float transparency = 1.f;
		};

		class imageType : public baseType {
		public:
			char data[512];

			ImVec2 position = { 0.f, 0.f };
			ImVec4 color = { 0.f, 0.f, 0.f, 0.f };
			ImVec2 size = { 0.f, 0.f };

			float transparency = 1.f;
			int rounding = 0;
		};

		struct colorType {
			float r, g, b;

			operator ImVec4() { return { r, g, b, 1.f }; }
			operator ImVec4() const { return { r, g, b, 1.f }; }
		};
	public:
		static auto getSingleton() -> render*;
		auto load() -> void;
		auto add(baseType* base) -> void;
		auto remove(baseType* base) -> void;
		auto getFonts() -> std::vector<ImFont*>;
		auto clear() -> void;
	};
}