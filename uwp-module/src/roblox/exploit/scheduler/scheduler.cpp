#include "scheduler.h"
#include <roblox/exploit/classes/vfhook/vfhook.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <lualib.h>

namespace module {
	scheduler* scheduler::singleton{ nullptr };
	auto scheduler::getSingleton() -> scheduler* {
		if (singleton == nullptr)
			singleton = new scheduler();

		return singleton;
	};

	scheduler::scheduler() {
		this->taskScheduler = roblox::getTaskScheduler();
		schedulerHook = new vfhook();

		std::intptr_t jobStart{ *reinterpret_cast<std::intptr_t*>(this->taskScheduler + offsets::schedulerJobStart) };
		std::intptr_t jobEnd{ *reinterpret_cast<std::intptr_t*>(this->taskScheduler + offsets::schedulerJobEnd) };

		while (jobStart != jobEnd) {
			this->jobVector.push_back(*(std::intptr_t*)(jobStart));
			jobStart += 8;
		}
	};

	auto scheduler::reInitialize() -> void {
		this->taskScheduler = roblox::getTaskScheduler();
		this->jobVector.clear();

		std::intptr_t jobStart{ *reinterpret_cast<std::intptr_t*>(this->taskScheduler + offsets::schedulerJobStart) };
		std::intptr_t jobEnd{ *reinterpret_cast<std::intptr_t*>(this->taskScheduler + offsets::schedulerJobEnd) };

		while (jobStart != jobEnd) {
			this->jobVector.push_back(*(std::intptr_t*)(jobStart));
			jobStart += 8;
		}
	};

	auto scheduler::getJobName(std::intptr_t job) -> std::string {
		return *reinterpret_cast<std::string*>(job + offsets::schedulerJobName);
	};

	auto scheduler::getJob(std::string_view name) -> std::intptr_t {
		std::intptr_t jobRet{ NULL };
		std::string oName{ obfuscate_str("WaitingHybridScriptsJob") };

		if (name == oName) {
			for (std::intptr_t job : this->jobVector) {
				if (this->getJobName(job) == name) {
					auto datamodel = this->getDataModel(job);
					auto gameId = *reinterpret_cast<std::intptr_t*>(datamodel + module::datamodelGameId);
					if (gameId != NULL) {
						return job;
					}
				}
			}
		}
		else {
			for (std::intptr_t job : this->jobVector) {
				if (this->getJobName(job) == name)
					jobRet = job;
			}
		}

		return jobRet;
	};

	auto scheduler::jobHook(void* hookFunc) -> std::intptr_t {
		this->schedulerHook->evictHook((void*)this->getScriptJob(), 6);
		return this->schedulerHook->hook(2, hookFunc);
	};

	auto scheduler::setFps(double fps) -> void {
		*reinterpret_cast<double*>(this->taskScheduler + module::schedulerFps) = 1 / fps;
	}

	auto scheduler::getFps() -> double {
		return (1 / *reinterpret_cast<double*>(this->taskScheduler + module::schedulerFps));
	}

	auto scheduler::getScriptJob() -> std::intptr_t {
		std::string name{ obfuscate_str("WaitingHybridScriptsJob") };
		return this->getJob(name);
	}

	auto scheduler::getScriptContext(std::intptr_t scriptJob) -> std::intptr_t {
		return *reinterpret_cast<std::intptr_t*>((scriptJob == -1 ? this->getScriptJob() : scriptJob) + offsets::scriptJobScriptContext);
	};

	auto scheduler::getDataModel(std::intptr_t scriptJob) -> std::intptr_t {
		return (*reinterpret_cast<std::intptr_t*>((scriptJob == -1 ? this->getScriptJob() : scriptJob) + offsets::scriptJobDataModel));
	};

	auto scheduler::getLuaState(std::intptr_t context) -> lua_State* {
		std::intptr_t script[] = { 0, 0 };
		std::intptr_t identity{ 0 };
		return  roblox::getState((context == -1 ? this->getScriptContext() : context), &identity, script);
	};

	auto scheduler::getRawDataModel() -> std::intptr_t { /* Okay I get it I got lazy I admit it I stayed up all night and it was 10 am at the time */
		std::intptr_t taskSchedulerAddy = roblox::getTaskScheduler();

		std::intptr_t jobStart{ *reinterpret_cast<std::intptr_t*>(taskSchedulerAddy + offsets::schedulerJobStart) };
		std::intptr_t jobEnd{ *reinterpret_cast<std::intptr_t*>(taskSchedulerAddy + offsets::schedulerJobEnd) };
		std::intptr_t JAJA = NULL;

		std::string name{ obfuscate_str("WaitingHybridScriptsJob") };
		while (jobStart != jobEnd) {
			std::intptr_t job = *(std::intptr_t*)(jobStart);

			if (this->getJobName(job) == name) {
				JAJA = job;
				auto datamodel = this->getDataModel(job);
				auto gameId = *reinterpret_cast<std::intptr_t*>(datamodel + module::datamodelGameId);
				if (gameId != NULL) {
					return datamodel;
				}
			}

			jobStart += 8;
		}

		return this->getDataModel(JAJA);
	}

	auto scheduler::isLoaded() -> bool {
		return (this->taskScheduler != roblox::getTaskScheduler());
	}
}