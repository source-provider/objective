#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <roblox/exploit/classes/yield/yield.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <lualib.h>
#include <dependencies/luau/vm/src/lfunc.h>

const auto luauBytecode{ module::luauBytecode::getSingleton() };
const auto environment{ module::environment::getSingleton() };
const auto execution{ module::execution::getSingleton() };
const auto storage{ module::storage::getSingleton() };
std::unordered_map<Closure*, std::intptr_t> newcclosureMap;

using namespace module::roblox;
std::intptr_t loadModuleRef{ 0 };

auto getscriptclosure(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));
	if (strcmp(luaL_typename(L, 1), obfuscate_str("Instance")) != 0) {
		luaL_typeerror(L, 1, obfuscate_str("Instance"));
		return 0;
	}

	const char* currentClassName = environment->getClassName(L, 1);
	std::intptr_t script = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	if (strcmp(currentClassName, obfuscate_str("LocalScript")) == 0) {
		std::string localScriptBytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(script + module::localScriptBytecode) + 16);
		localScriptBytecode = luauBytecode->decompressBytecode(localScriptBytecode);

		if (localScriptBytecode[0] == 0) {
			return 0;
		}

		if (luau_load(L, obfuscate_str("=script"), localScriptBytecode.c_str(), localScriptBytecode.size(), 0) != LUA_OK) {
			lua_pop(L, 1);
			return 0;
		}

		return 1;
	}
	else if (strcmp(currentClassName, obfuscate_str("ModuleScript")) == 0) {
		if (loadModuleRef == NULL) {
			lua_State* th = lua_newthread(L);

			lua_getglobal(th, obfuscate_str("debug")); 
			lua_getfield(th, -1, obfuscate_str("loadmodule"));
			lua_clonefunction(th, -1);
			loadModuleRef = lua_ref(th, -1);

			lua_settop(th, 0);
		}

		*reinterpret_cast<bool*>(module::addresses::loadModuleFlag) = true;
		lua_getref(L, loadModuleRef);
		lua_pushvalue(L, 1);
		lua_pcall(L, 1, 1, 0);
		*reinterpret_cast<bool*>(module::addresses::loadModuleFlag) = false;

		return 1;
	}

	environment->checkClassName(L, 1, obfuscate_str("LocalScript or ModuleScript"));
	return 0;
};

auto newcclosureStub(lua_State* L) -> std::intptr_t {
	const auto nargs = lua_gettop(L);
	std::intptr_t closureRef = newcclosureMap.find(clvalue(L->ci->func))->second;

	if (closureRef == NULL) {
		return 0;
	}

	lua_getref(L, closureRef);
	lua_insert(L, 1);

	const char* error;
	const auto res = lua_pcall(L, nargs, LUA_MULTRET, 0);

	if (res && res != LUA_YIELD && (error = lua_tostring(L, -1), !std::strcmp(error, "attempt to yield across metamethod/C-call boundary"))) {
		return lua_yield(L, 0);
	}

	if (res != LUA_OK) {
		luaL_error(L, "%s", lua_tostring(L, -1));
		return 0;
	}

	return lua_gettop(L);
};

auto newcclosure(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TFUNCTION));

	if (lua_iscfunction(L, 1)) {
		lua_pushvalue(L, 1);
		return 1;
	}
	
	lua_pushcclosure(L, newcclosureStub, 0, 0);
	newcclosureMap[&luaA_toobject(L, -1)->value.gc->cl] = lua_ref(L, 1);

	return 1;
};

auto hookfunction(lua_State* L) -> std::intptr_t { /* vice versa closure support gonna be written in lua */
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TFUNCTION));
	checkType(L, 2, LUA_TFUNCTION);

	Closure* hookTo = (Closure*)lua_topointer(L, 1);
	Closure* hookWith = (Closure*)lua_topointer(L, 2);

	if (hookTo->isC == TRUE) {
		std::intptr_t hookWithRef = lua_ref(L, 2);
		lua_CFunction func1 = hookWith->c.f;

		lua_clonefunction(L, 1); /* clone the cclosure */

		hookTo->c.f = [](lua_State* L) -> std::intptr_t { return 0; }; /* we don't wanna break while we set upvalues */

		for (auto i = 0; i < hookWith->nupvalues; i++) {
			TValue* oldTval = &hookTo->c.upvals[i];
			TValue* hookTval = &hookWith->c.upvals[i];

			oldTval->value = hookTval->value;
			oldTval->tt = hookTval->tt;
		}

		std::intptr_t closureRef = newcclosureMap.find(hookTo)->second;
		if (closureRef != NULL) {
			newcclosureMap[hookTo] = hookWithRef;
			newcclosureMap[clvalue(luaA_toobject(L, -1))] = closureRef;
		}

		hookTo->nupvalues = hookWith->nupvalues;
		hookTo->c.f = func1;

		return 1;
	}
	else {
		/*if (hookWith->nupvalues > hookTo->nupvalues) {
			luaL_argerror(L, 2, "too many upvalues");
			return 0;
		}*/

		Proto* nProto = hookWith->l.p;
		lua_clonefunction(L, 1); /* clones the lclosure */

		hookTo->env = hookWith->env; /* not sure if this could be a vuln because you could hook a game lclosure and be able to access our env (KEEPING FOR DEBUG)*/

		hookTo->stacksize = hookWith->stacksize;
		hookTo->preload = hookWith->preload;

		for (int i = 0; i < hookWith->nupvalues; ++i)
			setobj2n(L, &hookTo->l.uprefs[i], &hookWith->l.uprefs[i]);

		hookTo->nupvalues = hookWith->nupvalues;
		hookTo->l.p = nProto;

		return 1;
	}

	return 0;
};

auto hookmetamethod(lua_State* L) -> std::intptr_t {
	return 0;
};

auto checkcaller(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);

	lua_pushboolean(L, (L->extra_space->context_level > 3));
	return 1;
};

auto getcallingscript(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);

	lua_getglobal(L, obfuscate_str("script"));
	/*if (!L->extra_space->script_1.expired()) {
		auto temporary = (L->extra_space->script_1).lock();
		pushInstanceW(L, temporary);
	}
	else
		lua_pushnil(L);*/

	return 1;
};

auto islclosure(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TFUNCTION));
	lua_pushboolean(L, lua_isLfunction(L, 1));
	return 1;
};

auto iscclosure(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TFUNCTION));
	lua_pushboolean(L, lua_iscfunction(L, 1));
	return 1;
};

auto checkclosure(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TFUNCTION));
	Closure* cl = (Closure*)lua_topointer(L, 1);
	auto closureList = getClosureList();

	bool isOurClosure = false;
	if (closureList.find(cl) != closureList.end()) {
		isOurClosure = true;
	}

	lua_pushboolean(L, isOurClosure);
	return 1;
};

auto clonefunction(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TFUNCTION));

	if (lua_iscfunction(L, 1)) {
		Closure* cloneFunc = (Closure*)lua_topointer(L, 1);

		if (newcclosureMap.find(cloneFunc) != newcclosureMap.end()) {
			std::intptr_t closureRef = newcclosureMap.find(cloneFunc)->second;
			lua_pushcclosure(L, newcclosureStub, 0, 0);
			newcclosureMap[&luaA_toobject(L, -1)->value.gc->cl] = closureRef;

			return 1;
		}
	}

	lua_clonefunction(L, 1);
	return 1;
};

/* registering */
static const luaL_Reg envFuncs[] = {
	{"getscriptclosure", getscriptclosure},
	{"getscriptfunction", getscriptclosure},

	{"newcclosure", newcclosure},
	{"createcclosure", newcclosure},
	{"makecclosure", newcclosure},

	{"hookfunction", hookfunction},
	{"replaceclosure", hookfunction},
	{"replacefunction", hookfunction},
	{"replacefunc", hookfunction},
	{"detourfunction", hookfunction},
	{"detour_function", hookfunction},
	{"hookfunc", hookfunction},

	{"hookmetamethod", hookmetamethod},
	{"checkcaller", checkcaller},
	{"getcallingscript", getcallingscript},

	{"islclosure", islclosure},
	{"iscclosure", iscclosure},
	{"islfunction", islclosure},
	{"iscfunction", iscclosure},
	{"islfunc", islclosure},
	{"iscfunc", iscclosure},

	{"checkclosure", checkclosure},
	{"isourclosure", checkclosure},
	{"isexecutorclosure", checkclosure},
	{"is_krnl_closure", checkclosure},
	{"is_nihon_closure", checkclosure},
	{"iscometfunction", checkclosure},
	{"is_comet_function", checkclosure},
	{"is_comet_closure", checkclosure},
	{"is_our_closure", checkclosure},
	{"is_synapse_function", checkclosure},
	{"iscometclosure", checkclosure},
	{"is_executor_closure", checkclosure},
	{"is_protosmasher_closure", checkclosure},

	{"clonefunction", clonefunction},
	{"clonefunc", clonefunction},
	{"cloneclosure", clonefunction},
	{NULL, NULL}
};

auto module::environment::createClosure(lua_State* L) -> void {
	loadModuleRef = NULL;
	lua_pushvalue(L, LUA_GLOBALSINDEX);
	luaL_register(L, NULL, envFuncs);
	lua_pop(L, 1);
}