#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <roblox/exploit/classes/yield/yield.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <lualib.h>

auto getrawmetatable(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1);
	int t1 = lua_type(L, 1);
	if (t1 != LUA_TTABLE && t1 != LUA_TUSERDATA) {
		luaL_typeerror(L, 1, "table or userdata");
		return 0;
	}

	if (!lua_getmetatable(L, 1))
		lua_pushnil(L);

	return 1;
}

auto setrawmetatable(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2);
	int t1 = lua_type(L, 1);
	if (t1 != LUA_TTABLE && t1 != LUA_TUSERDATA) {
		luaL_typeerror(L, 1, "table or userdata");
		return 0;
	}

	int t2 = lua_type(L, 2);
	if (t2 != LUA_TTABLE && t2 != LUA_TNIL) {
		luaL_typeerror(L, 2, "nil or table");
		return 0;
	}

	lua_settop(L, 2);
	lua_pushboolean(L, lua_setmetatable(L, 1));

	return 1;
}

auto setreadonly(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TTABLE));
	luaL_checktype(L, 2, LUA_TBOOLEAN);

	Table* t = (Table*)lua_topointer(L, 1);
	t->readonly = lua_toboolean(L, 2);

	return 0;
}

auto isreadonly(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TTABLE));

	Table* t = (Table*)lua_topointer(L, 1);
	lua_pushboolean(L, t->readonly);

	return 1;
}

auto iswriteable(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TTABLE));

	Table* t = (Table*)lua_topointer(L, 1);
	lua_pushboolean(L, !t->readonly);

	return 1;
}

auto makereadonly(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TTABLE));

	Table* t = (Table*)lua_topointer(L, 1);
	t->readonly = TRUE;

	return 0;
}

auto makewriteable(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TTABLE));

	Table* t = (Table*)lua_topointer(L, 1);
	t->readonly = FALSE;

	return 0;
}

auto getnamecallmethod(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);

	if (L->namecall != NULL)  {
		lua_pushstring(L, L->namecall->data);
		return 1;
	}

	return 0;
}

auto setnamecallmethod(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	L->namecall = tsvalue(luaA_toobject(L, 1));
	return 0;
}


/* registering */
static const luaL_Reg envFuncs[] = {
	{"getrawmetatable", getrawmetatable},
	{"setrawmetatable", setrawmetatable},
	{"setreadonly", setreadonly},
	{"isreadonly", isreadonly},
	{"iswriteable", iswriteable},
	{"makereadonly", makereadonly},
	{"makewriteable", makewriteable},
	{"getnamecallmethod", getnamecallmethod},
	{"setnamecallmethod", setnamecallmethod},

	{NULL, NULL}
};

auto module::environment::createMetatable(lua_State* L) -> void {
	lua_pushvalue(L, LUA_GLOBALSINDEX);
	luaL_register(L, NULL, envFuncs);
	lua_pop(L, 1);
}