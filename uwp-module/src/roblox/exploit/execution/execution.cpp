#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <roblox/exploit/classes/console/console.h>
#include <roblox/miscellaneous/configuration.hpp>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/ldo.h>
#include <utilities/utils/utils.h>
#include <Luau/BytecodeBuilder.h>
#include <Luau/Compiler.h>
#include "execution.h"
#include <lualib.h>
#include <mutex>


module::execution* executionSingleton{ nullptr };
module::scheduler::jobType schedulerRet{ NULL };
auto utilities{ module::utils::getSingleton() };
static std::intptr_t taskDeferRef{ NULL };
std::mutex mutex;

auto setIdentity(lua_State* L, std::intptr_t identity) -> void {
	std::intptr_t identityObfuscated = 63;
	switch (identity) {
	case 1:
		identityObfuscated = 3;
		break;
	case 2:
		identityObfuscated = 3;
		break;
	case 3:
		identityObfuscated = 3;
		break;
	case 4:
		identityObfuscated = 3;
		break;
	case 5:
		identityObfuscated = 1;
		break;
	case 6:
		identityObfuscated = 11;
		break;
	case 7:
		identityObfuscated = 63;
		break;
	case 8:
		identityObfuscated = 63;
		break;
	case 9:
		identityObfuscated = 12;
		break;
	default:
		identityObfuscated = 0;
		break;
	}

	if (identity > 9) {
		identityObfuscated = 12;
	}

	(*((std::intptr_t*)&(identityObfuscated))) = (identityObfuscated | 0x300);
	*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<void**>(reinterpret_cast<std::int32_t>(NtCurrentTeb()) + 44)) + module::identityImpersonator) = identity;
	L->extra_space->faggot_context = identityObfuscated;
	L->extra_space->context_level = identity;
}

auto __fastcall schedulerHook(std::intptr_t self, std::intptr_t _, std::intptr_t a2) -> std::uintptr_t { 
	std::unique_lock<std::mutex> guard{ mutex };
	if (!executionSingleton->empty()) {
		module::schedulerTask task = executionSingleton->top();
		guard.unlock();

		auto taskScheduler{ module::scheduler::getSingleton() };
		auto console{ module::console::getSingleton() };
		auto luauBytecode{ module::luauBytecode::getSingleton() };

		auto luaState{ taskScheduler->getLuaState() };

		if (task.isc) {
			try {
				task.func(luaState);
			}
			catch (lua_exception& ex) {
				console->writeMode(ex.what(), module::console::error);
			}
			catch (std::exception ex) {
				console->writeMode(ex.what(), module::console::error);
			}
		}
		else {
			lua_State* oLuaState = luaState;
			luaState = lua_newthread(luaState);
			lua_pop(oLuaState, 1);

			if (taskDeferRef == NULL) {
				lua_getglobal(luaState, obfuscate_str("task"));
				lua_getfield(luaState, -1, obfuscate_str("defer"));

				lua_clonefunction(luaState, -1);
				taskDeferRef = lua_ref(luaState, -1);

				lua_settop(luaState, 0);
			}

			static std::string startScript{ obfuscate_str("script=Instance.new(\"LocalScript\");\t") };
			const std::string& luaScript{ (startScript + task.script) };
			std::string bytecode{ luauBytecode->compileBytecode(luaScript) };

			setIdentity(luaState, 8);

			if (bytecode[0] == 0) {
				std::string err{ bytecode.c_str() + 1 };
				console->writeMode(err, module::console::error);
			}
			else {
				lua_getref(luaState, taskDeferRef);
				if (luau_load(luaState, utilities->randomString(16).c_str(), bytecode.c_str(), bytecode.size(), 0) == LUA_OK) {
					if (lua_pcall(luaState, 1, 0, 0) != LUA_OK) {
						console->writeMode(lua_tostring(luaState, -1), module::console::error);
						lua_pop(luaState, 2);
					}
				}
				else {
					console->writeMode(lua_tostring(luaState, -1), module::console::error);
					lua_pop(luaState, 2);
				}
			}

			lua_settop(luaState, 0);
		}
	}

	return schedulerRet(self, a2);
}

namespace module {
	execution* execution::singleton{ nullptr };
	auto execution::getSingleton() -> execution* {
		if (singleton == nullptr)
			singleton = new execution();

		return singleton;
	};

	auto execution::load() -> void {
		taskDeferRef = 0;

		executionSingleton = this;
		auto taskScheduler{ module::scheduler::getSingleton() };
		schedulerRet = reinterpret_cast<scheduler::jobType>(taskScheduler->jobHook(schedulerHook));
	};

	auto execution::createPipe() -> void {
		if (this->pipeInitialize)
			return;

		this->pipeInitialize = true;

		std::thread(
			[this]() -> void {
				DWORD read{};
				char bufferSize[999999];

				std::string obfuscatedName{ obfuscate_str(cPipeName) };
				std::string obfuscatedPipe{ obfuscate_str("\\\\.\\pipe\\local\\") };
#				if usePidForPipe
				std::string pipeName{ obfuscatedPipe + obfuscatedName + utilities->numberToString(_getpid()) };
#				else
				std::string pipeName{ obfuscatedPipe + obfuscatedName };
#				endif

				std::string luaCode{ "" };

				HANDLE pipe{ CreateNamedPipeA(pipeName.c_str(), PIPE_ACCESS_DUPLEX | PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, PIPE_WAIT, 1, 9999999, 9999999, NMPWAIT_USE_DEFAULT_WAIT, nullptr) };
				while (pipe != INVALID_HANDLE_VALUE) {
					if (ConnectNamedPipe(pipe, nullptr) != FALSE) {
						while (ReadFile(pipe, bufferSize, sizeof(bufferSize) - 1, &read, nullptr) != FALSE) {
							bufferSize[read] = '\0';
							luaCode += bufferSize;
						}

						this->send(luaCode);
						luaCode.clear();
					}

					DisconnectNamedPipe(pipe);
				}
			}
		).detach();
	};

	auto execution::send(std::string script, std::string chunk, lua_State* L) -> std::intptr_t {
		std::unique_lock<std::mutex> guard{ mutex };
		if (L == nullptr) { // push to scheduler
			this->schedulerQueue.push(schedulerTask{ script });
		} else {
			struct : Luau::BytecodeEncoder {
				auto encodeOp(const std::uint8_t op) -> uint8_t override {
					return op * 227;
				}
			} bytecodeEncoder;

			const std::string& bytecode = Luau::compile(script, {}, {}, &bytecodeEncoder);

			if (chunk == "") {
				chunk = utilities->randomString(16).c_str();
			}

			if (luau_load(L, chunk.c_str(), bytecode.c_str(), bytecode.size(), 0) == LUA_OK) {
				return 1;
			}
			else {
				std::string err = lua_tostring(L, -1);
				lua_pop(L, 1);

				lua_pushnil(L);
				lua_pushlstring(L, err.c_str(), err.size());
				return 2;
			}
		}

		return 0;
	}

	auto execution::send(std::function<void(lua_State* L)> func) -> std::intptr_t {
		std::unique_lock<std::mutex> guard{ mutex };
		this->schedulerQueue.push(schedulerTask{ func });
		return 0;
	}

	auto execution::empty() -> bool {
		return this->schedulerQueue.empty();
	};

	auto execution::top() -> schedulerTask {
		module::schedulerTask task{ this->schedulerQueue.front() };
		this->schedulerQueue.pop();
		return task;
	};

	auto execution::resume(lua_State* L, std::intptr_t results) -> std::intptr_t {
		lua_State* th = lua_newthread(L);

		if (taskDeferRef == NULL) {
			lua_getglobal(th, obfuscate_str("task"));
			lua_getfield(th, -1, obfuscate_str("defer"));

			lua_clonefunction(th, -1);
			taskDeferRef = lua_ref(th, -1);

			lua_settop(th, 0);
		}

		lua_getref(th, taskDeferRef);

		lua_pushthread(L);
		lua_xmove(L, th, 1);
		lua_pop(L, 1);

		for (int i = results; i >= 1; i--) {
			lua_pushvalue(L, -i);
			lua_xmove(L, th, 1);
		}

		lua_pcall(th, results + 1, 0, 0);
		lua_settop(th, 0);
		return 0;
	}
}