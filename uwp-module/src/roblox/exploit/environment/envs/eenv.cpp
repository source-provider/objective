#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <roblox/exploit/classes/yield/yield.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lmem.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <utilities/utils/utils.h>
#include <filesystem>
#include <lualib.h>
#include <fstream>



const auto luauBytecode{ module::luauBytecode::getSingleton() };
const auto environment{ module::environment::getSingleton() };
const auto execution{ module::execution::getSingleton() };
const auto storage{ module::storage::getSingleton() };
const auto utils{ module::utils::getSingleton() };

using namespace module::roblox;

auto loadstring(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 2, checkType(L, 1, LUA_TSTRING));
	std::string code{ lua_tostring(L, 1) };
	std::string chunk{ luaL_optstring(L, 2, "") };

	return execution->send(code, chunk, L);
}

auto getidentity(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);
	lua_pushnumber(L, L->extra_space->context_level);
	return 1;
}

auto setidentity(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TNUMBER));
	setIdentity(L, lua_tonumber(L, 1));
	return 0;
};

auto getscriptfromthread(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TTHREAD));
	lua_State* thread = lua_tothread(L, 1);
	lua_getglobal(thread, obfuscate_str("script"));
	lua_xmove(thread, L, 1);

	/*if (!thread->extra_space->script_1.expired()) {
		auto temporary = (thread->extra_space->script_1).lock();
		pushInstanceW(L, temporary);
	}
	else
		lua_pushnil(L);*/

	return 1;
};

auto gethui(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);

	lua_getglobal(L, obfuscate_str("game"));
	lua_getfield(L, -1, obfuscate_str("GetService"));

	lua_pushvalue(L, -2);
	lua_pushstring(L, obfuscate_str("CoreGui"));

	lua_pcall(L, 2, 1, 0);

	return 1;
};

auto getgenv(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);
	lua_pushvalue(L, LUA_GLOBALSINDEX);
	return 1;
}

auto getrenv(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);
	Table* renv = storage->find<Table*>(obfuscate_str("robloxGlobalTable"));
	sethvalue(L, L->top, renv);
	L->top++;
	return 1;
}

auto getreg(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);
	lua_pushvalue(L, LUA_REGISTRYINDEX);
	return 1;
};

auto getgc(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 1);
	bool tables = luaL_optboolean(L, 1, false);

	struct gc_context {
		lua_State* L;
		std::intptr_t n;
		bool is_table;
	} context = { L, 0, tables };

	lua_createtable(L, 0, 0);
	for (lua_Page* page = L->global->allgcopages; page;) {
		lua_Page* next{ page->gcolistnext }; // block visit might destroy the page

		luaM_visitpage(page, &context,
			[](void* context, lua_Page* page, GCObject* gco) -> bool {
				gc_context* gcContext{ reinterpret_cast<gc_context*>(context) };
				auto type = gco->gch.tt;

				if (type == LUA_TUSERDATA || type == LUA_TFUNCTION || (type == LUA_TTABLE && gcContext->is_table)) {
					TValue* top = gcContext->L->top;
					top->value.p = reinterpret_cast<void*>(gco);
					top->tt = type;
					gcContext->L->top++;

					gcContext->n++;
					lua_rawseti(gcContext->L, -2, gcContext->n);
				}

				return true;
			}
		);

		page = next;
	}

	return 1;
};

auto getsenv(lua_State* L) -> std::intptr_t { /* I'm tooooo fucking lazy to do this shit */
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));
	if (strcmp(luaL_typename(L, 1), "Instance") != 0) {
		luaL_typeerrorL(L, 1, "Instance");
		return 0;
	}

	const char* currentClassName = environment->getClassName(L, 1);
	if (strcmp(currentClassName, "LocalScript") == 0) {
		return 0;
	}
	else if (strcmp(currentClassName, "ModuleScript") == 0) {
		return 0;
	}

	environment->checkClassName(L, 1, "LocalScript or ModuleScript");
	return 0;
};

#pragma region getconnection shit
struct connection_t {
	std::intptr_t object;
	void* orignal_object;
	std::intptr_t old_state;
};

std::unordered_map<std::intptr_t, connection_t> connections;
auto enableConnection(lua_State* L) -> std::intptr_t {
	const auto signal = *(std::intptr_t*)lua_touserdata(L, 1);

	if (!connections.count(signal)) {
		connection_t new_c;
		new_c.orignal_object = lua_touserdata(L, 1);
		new_c.object = signal;
		new_c.old_state = *reinterpret_cast<std::intptr_t*>(signal + module::signalState);

		connections[signal] = new_c;
	}

	*reinterpret_cast<std::intptr_t*>(signal + module::signalState) = connections[signal].old_state;
	return 0;
}

auto disableConnection(lua_State* L) -> std::intptr_t {
	const auto signal = *(std::intptr_t*)lua_touserdata(L, 1);

	if (!connections.count(signal)) {
		connection_t new_c;
		new_c.orignal_object = lua_touserdata(L, 1);
		new_c.object = signal;
		new_c.old_state = *reinterpret_cast<std::intptr_t*>(signal + module::signalState);

		connections[signal] = new_c;
	}

	*reinterpret_cast<std::intptr_t*>(signal + module::signalState) = 0;
	return 0;
}

auto blankFunction(lua_State* L) -> std::intptr_t {
	return 0;
}

auto indexConnection(lua_State* L) -> std::intptr_t {
	const std::string key = lua_tolstring(L, 2, nullptr);

	if (key == "Enable" || key == "enable") {
		lua_pushvalue(L, 1);
		lua_pushcfunction(L, enableConnection, 0);
	}
	else if (key == "Function" || key == "function" || key == "Fire" || key == "fire" || key == "Defer" || key == "defer") {
		const auto connection = *reinterpret_cast<connection_t*>(lua_touserdata(L, 1));
		//std::intptr_t num = *reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::intptr_t*>(connection.object + 72) + 100) + 8);
		//lua_getref(L, );
		lua_pushcfunction(L, blankFunction, 0);
		//lua_pushnumber(L, num);
		/*if (lua_type(L, -1) <= 0)
			lua_pushcfunction(L, blankFunction, 0);*/
	}
	else if (key == "Enabled" || key == "enabled" || key == "State" || key == "state") {
		const auto Signal = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
		const auto conn = *reinterpret_cast<std::intptr_t*>(Signal + module::signalState);

		lua_pushboolean(L, conn);
		//*reinterpret_cast<int*>(Signal + rbxscriptsignal_state) = 0;
	}
	else if (key == "Disable" || key == "disable" || key == "Disconnect" || key == "disconnect") /* doing Disconnect this way but will chjange it later */ {
		lua_pushvalue(L, 1);
		lua_pushcfunction(L, disableConnection, 0);
	}
	else if (key == "LuaConnection" || key == "luaconnection") {
		//const auto connection = *reinterpret_cast<connection_t*>(lua_touserdata(L, 1));
		//lua_getref(L, *reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::intptr_t*>(*reinterpret_cast<std::intptr_t*>(connection.object + module::signalRef0) + module::signalRef1) + module::signalRefIdx));
		lua_pushcfunction(L, blankFunction, 0);
		if (lua_type(L, -1) == LUA_TFUNCTION) {
			lua_pushboolean(L, lua_isLfunction(L, -1));
		}
		else {
			lua_pushboolean(L, false);
		}
	}
	else {
		lua_pushnil(L);
	}

	return 1;
}

auto getconnections(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));

	lua_getfield(L, 1, "Connect");
	lua_pushvalue(L, 1);
	lua_pushcclosurek(L, blankFunction, NULL, NULL, NULL);
	lua_pcall(L, 2, 1, 0);

	const auto signal = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, -1));
	auto next = *reinterpret_cast<std::intptr_t*>(signal + module::signalNext);

	lua_createtable(L, 0, 0);
	auto count = 1;

	while (next != 0) {

		if (connections.count(next)) {
			*reinterpret_cast<connection_t*>(lua_newuserdata(L, sizeof(connection_t), 0)) = connections[next];

			lua_createtable(L, 0, 0);
			lua_pushcfunction(L, indexConnection, 0);
			lua_setfield(L, -2, "__index");
			lua_pushstring(L, "table");
			lua_setfield(L, -2, "__type");
			lua_setmetatable(L, -2);
		}
		else {
			connection_t new_connection;
			new_connection.orignal_object = lua_touserdata(L, 1);
			new_connection.object = next;
			new_connection.old_state = *reinterpret_cast<std::intptr_t*>(next + module::signalState);

			*reinterpret_cast<connection_t*>(lua_newuserdata(L, sizeof(connection_t), 0)) = new_connection;

			lua_createtable(L, 0, 0);
			//r_lua_newtable(rL);
			lua_pushcfunction(L, indexConnection, 0);
			lua_setfield(L, -2, "__index");
			lua_pushstring(L, "table");
			lua_setfield(L, -2, "__type");
			lua_setmetatable(L, -2);

			connections[next] = new_connection;
		}

		lua_rawseti(L, -2, count++);
		next = *reinterpret_cast<std::intptr_t*>(next + module::signalNext);
	}

	lua_getfield(L, -2, "Disconnect");
	lua_pushvalue(L, -3);
	lua_pcall(L, 1, 0, 0);

	return 1;
}

auto firesignal(lua_State* L) -> std::intptr_t {
	return 0;
};

#pragma endregion

auto gethiddenproperty(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA););
	if (strcmp(luaL_typename(L, 1), "Instance") != 0) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	checkType(L, 2, LUA_TSTRING);

	const auto instance = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	std::string propertyWanted = lua_tostring(L, 2);

	const auto classDescriptor = *reinterpret_cast<std::intptr_t*>(instance + module::instanceClassDescriptor);
	for (std::intptr_t property : *reinterpret_cast<std::vector<std::intptr_t>*>(classDescriptor + module::classDescriptorProperties)) {
		std::string propertyName = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorName));
		bool isScriptable = (bool)((*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) >> 5) & 1);

		if (propertyName == propertyWanted) {
			if (isScriptable == FALSE) {
				std::intptr_t oldScriptable = *reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable);
				*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) = (1 << 5);
				lua_getfield(L, 1, propertyName.c_str());
				*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) = oldScriptable;
			}
			else {
				lua_getfield(L, 1, propertyWanted.c_str());
			}

			lua_pushboolean(L, !isScriptable);
			return 2;
		}

	}

	return 0;
}

auto sethiddenproperty(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA););
	if (strcmp(luaL_typename(L, 1), "Instance") != 0) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	checkType(L, 2, LUA_TSTRING);

	const auto instance = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	std::string propertyWanted = lua_tostring(L, 2);

	const auto classDescriptor = *reinterpret_cast<std::intptr_t*>(instance + module::instanceClassDescriptor);
	for (std::intptr_t property : *reinterpret_cast<std::vector<intptr_t>*>(classDescriptor + module::classDescriptorProperties)) {
		std::string propertyName = *reinterpret_cast<std::string*>(*reinterpret_cast<intptr_t*>(property + module::propertyDescriptorName));
		bool isScriptable = (bool)((*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) >> 5) & 1);

		if (propertyName == propertyWanted) {
			if (isScriptable == FALSE) {
				std::intptr_t oldScriptable = *reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable);
				*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) = (1 << 5);
				lua_pushvalue(L, 3);
				lua_setfield(L, 1, propertyName.c_str());
				*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) = oldScriptable;
			}
			else {
				lua_pushvalue(L, 3);
				lua_setfield(L, 1, propertyWanted.c_str());
			}

			lua_pushboolean(L, !isScriptable);
			return 1;
		}

	}

	return 0;
}

auto isscriptable(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA););
	if (strcmp(luaL_typename(L, 1), "Instance") != 0) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	checkType(L, 2, LUA_TSTRING);

	const auto instance = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	std::string propertyWanted = lua_tostring(L, 2);

	const auto classDescriptor = *reinterpret_cast<std::intptr_t*>(instance + module::instanceClassDescriptor);
	for (std::intptr_t property : *reinterpret_cast<std::vector<std::intptr_t>*>(classDescriptor + module::classDescriptorProperties)) {
		std::string propertyName = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorName));

		if (propertyName == propertyWanted) {
			bool isScriptable = (bool)((*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) >> 5) & 1);
			lua_pushboolean(L, isScriptable);
			return 1;
		}
	}

	return 0;
}

auto setscriptable(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA););
	if (strcmp(luaL_typename(L, 1), "Instance") != 0) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	checkType(L, 2, LUA_TSTRING);
	checkType(L, 3, LUA_TBOOLEAN);

	const auto instance = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	std::string propertyWanted = lua_tostring(L, 2);
	bool scriptableBoolean = lua_toboolean(L, 3);

	const auto classDescriptor = *reinterpret_cast<std::intptr_t*>(instance + module::instanceClassDescriptor);
	for (std::intptr_t property : *reinterpret_cast<std::vector<std::intptr_t>*>(classDescriptor + module::classDescriptorProperties)) {
		std::string propertyName = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorName));

		if (propertyName == propertyWanted) {
			bool isScriptable = (bool)((*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) >> 5) & 1);
			*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) = (scriptableBoolean << 5);
			lua_pushboolean(L, isScriptable);
			return 1;
		}
	}

	return 0;
}

auto getproperties(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA););
	if (strcmp(luaL_typename(L, 1), "Instance") != 0) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	const auto instance = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	const auto classDescriptor = *reinterpret_cast<std::intptr_t*>(instance + module::instanceClassDescriptor);

	lua_createtable(L, 0, 0);

	std::intptr_t tabPos = 0;
	for (std::intptr_t property : *reinterpret_cast<std::vector<std::intptr_t>*>(classDescriptor + module::classDescriptorProperties)) {
		std::string propertyName = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorName));

		lua_pushlstring(L, propertyName.c_str(), propertyName.size());
		lua_rawseti(L, -2, ++tabPos);
	}

	return 1;
};

auto gethiddenproperties(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA););
	if (strcmp(luaL_typename(L, 1), "Instance") != 0) {
		luaL_typeerror(L, 1, "Instance");
		return 0;
	}

	const auto instance = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	const auto classDescriptor = *reinterpret_cast<std::intptr_t*>(instance + 12);

	lua_createtable(L, 0, 0);

	std::intptr_t tabPos = 0;
	for (std::intptr_t property : *reinterpret_cast<std::vector<std::intptr_t>*>(classDescriptor + module::classDescriptorProperties)) {
		std::string propertyName = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorName));
		bool isScriptable = (bool)((*reinterpret_cast<std::intptr_t*>(property + module::propertyDescriptorScriptable) >> 5) & 1);

		if (isScriptable == false) {
			lua_pushlstring(L, propertyName.c_str(), propertyName.size());
			lua_rawseti(L, -2, ++tabPos);
		}
	}

	return 1;
};

auto getinstances(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);

	struct instance_context {
		lua_State* L;
		std::intptr_t n;
	} context = { L, 0 };

	lua_createtable(L, 0, 0);
	for (lua_Page* page = L->global->allgcopages; page;) {
		lua_Page* next{ page->gcolistnext }; // block visit might destroy the page

		luaM_visitpage(page, &context,
			[](void* context, lua_Page* page, GCObject* gco) -> bool {
				instance_context* gcContext{ reinterpret_cast<instance_context*>(context) };
				auto type = gco->gch.tt;

				if (type == LUA_TUSERDATA) {
					

					TValue* top = gcContext->L->top;
					top->value.p = reinterpret_cast<void*>(gco);
					top->tt = type;
					gcContext->L->top++;

					if (!strcmp(luaL_typename(gcContext->L, -1), "Instance")) {
						gcContext->n++;
						lua_rawseti(gcContext->L, -2, gcContext->n);
					}
					else {
						lua_pop(gcContext->L, 1);
					}
				}

				return true;
			}
		);

		page = next;
	}

	return 1;
}

auto getnilinstances(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);
	struct instance_context {
		lua_State* L;
		std::intptr_t n;
	} context = { L, 0 };

	lua_createtable(L, 0, 0);
	for (lua_Page* page = L->global->allgcopages; page;) {
		lua_Page* next{ page->gcolistnext }; // block visit might destroy the page

		luaM_visitpage(page, &context,
			[](void* context, lua_Page* page, GCObject* gco) -> bool {
				instance_context* gcContext{ reinterpret_cast<instance_context*>(context) };
				auto type = gco->gch.tt;

				if (type == LUA_TUSERDATA) {


					TValue* top = gcContext->L->top;
					top->value.p = reinterpret_cast<void*>(gco);
					top->tt = type;
					gcContext->L->top++;

					if (!strcmp(luaL_typename(gcContext->L, -1), "Instance")) {
						lua_getfield(gcContext->L, -1, "Parent");
						bool nullParent = lua_isnoneornil(gcContext->L, -1);

						if (nullParent) {
							lua_pop(gcContext->L, 1);
							gcContext->n++;
							lua_rawseti(gcContext->L, -2, gcContext->n);
						}
						else {
							lua_pop(gcContext->L, 2);
						}
					}
					else {
						lua_pop(gcContext->L, 1);
					}
				}

				return true;
			}
		);

		page = next;
	}
	return 1;
}

auto getscriptbytecode(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA););
	if (strcmp(luaL_typename(L, 1), obfuscate_str("Instance")) != 0) {
		luaL_typeerror(L, 1, obfuscate_str("Instance"));
		return 0;
	}

	const char* currentClassName = environment->getClassName(L, 1);
	std::intptr_t script = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	if (strcmp(currentClassName, obfuscate_str("LocalScript")) == 0) {
		std::string localScriptBytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(script + module::localScriptBytecode) + 16);
		localScriptBytecode = luauBytecode->decompressBytecode(localScriptBytecode);

		if (localScriptBytecode[0] == 0)
			localScriptBytecode = "Invalid Bytecode";

		lua_pushlstring(L, localScriptBytecode.c_str(), localScriptBytecode.size());
		return 1;
	}
	else if (strcmp(currentClassName, obfuscate_str("ModuleScript")) == 0) {
		std::string moduleScriptBytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(script + module::moduleScriptBytecode) + 16);
		moduleScriptBytecode = luauBytecode->decompressBytecode(moduleScriptBytecode);

		if (moduleScriptBytecode[0] == 0)
			moduleScriptBytecode = "Invalid Bytecode";

		lua_pushlstring(L, moduleScriptBytecode.c_str(), moduleScriptBytecode.size());
		return 1;
	}

	environment->checkClassName(L, 1, obfuscate_str("LocalScript or ModuleScript"));
	return 0;
}

auto getscripthash(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA););
	if (strcmp(luaL_typename(L, 1), obfuscate_str("Instance")) != 0) {
		luaL_typeerror(L, 1, obfuscate_str("Instance"));
		return 0;
	}

	const char* currentClassName = environment->getClassName(L, 1);
	std::intptr_t script = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	if (strcmp(currentClassName, "LocalScript") == 0) {
		std::string localScriptBytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(script + module::localScriptBytecode) + 16);
		localScriptBytecode = luauBytecode->decompressBytecode(localScriptBytecode);

		if (localScriptBytecode[0] == 0)
			localScriptBytecode = "Invalid Bytecode";

		localScriptBytecode = utils->hashWithAlgo<CryptoPP::SHA384>(localScriptBytecode);
		lua_pushlstring(L, localScriptBytecode.c_str(), localScriptBytecode.size());
		return 1;
	}
	else if (strcmp(currentClassName, "ModuleScript") == 0) {
		std::string moduleScriptBytecode = *reinterpret_cast<std::string*>(*reinterpret_cast<std::intptr_t*>(script + module::moduleScriptBytecode) + 16);
		moduleScriptBytecode = luauBytecode->decompressBytecode(moduleScriptBytecode);

		if (moduleScriptBytecode[0] == 0)
			moduleScriptBytecode = "Invalid Bytecode";

		moduleScriptBytecode = utils->hashWithAlgo<CryptoPP::SHA384>(moduleScriptBytecode);
		lua_pushlstring(L, moduleScriptBytecode.c_str(), moduleScriptBytecode.size());
		return 1;
	}

	environment->checkClassName(L, 1, "LocalScript or ModuleScript");
	return 0;
}

auto module::environment::getobjects(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA););
	checkType(L, 2, LUA_TSTRING);
	singleton->checkClassName(L, 1, "DataModel");

	lua_pushvalue(L, 1);
	lua_getfield(L, -1, "GetService");
	lua_pushvalue(L, 1);
	lua_pushstring(L, "InsertService");

	lua_pcall(L, 2, 1, 0);

	lua_getfield(L, -1, "LoadLocalAsset");
	lua_pushvalue(L, -2);
	lua_pushvalue(L, 2);

	lua_pcall(L, 2, 1, 0);

	lua_newtable(L);
	lua_pushvalue(L, -2);
	lua_rawseti(L, -2, 1);

	return 1;
}

auto getcustomasset(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string fileName = lua_tostring(L, 1);

	std::filesystem::path filePath = getDirectory() / fileName; 
	std::filesystem::path assetPath = std::filesystem::current_path() / "content" / filePath.filename();
	const size_t contentSize = std::filesystem::file_size(filePath);
	std::string result(contentSize, '\0');

	std::ifstream f(filePath, std::ios::in | std::ios::binary);
	f.read(result.data(), contentSize);

	std::ofstream out(assetPath, std::ios::out | std::ios::binary);
	out.write(result.c_str(), result.size());
	out.close();

	lua_pushstring(L, std::format("rbxasset://{}", assetPath.filename().string()).c_str());
	return 1;
};

auto fireclickdetector(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 2, checkType(L, 1, LUA_TUSERDATA));

	const auto detector = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(L, 1));
	const auto distance = static_cast<float>(luaL_optnumber(L, 2, 0));

	lua_getglobal(L, "game");
	lua_getfield(L, -1, "GetService");
	lua_pushvalue(L, -2);
	lua_pushstring(L, "Players");
	lua_pcall(L, 2, 1, 0);
	lua_getfield(L, -1, "LocalPlayer");

	const auto player = *reinterpret_cast<std::uintptr_t*>(lua_touserdata(L, -1));
	lua_pop(L, 3);

	fireClickDetector(detector, distance, player);

	lua_pushboolean(L, true);
	return 1;
};

auto firetouchinterest(lua_State* L) -> std::intptr_t {
	return 0;
};

auto fireproximityprompt(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA););

	int prox = *reinterpret_cast<std::intptr_t*>(lua_touserdata(L, 1));
	fireProximityPrompt(prox);
	return 0;
}

auto decompile(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));
	lua_pushstring(L, "-- decompiler coming soon! ~objective~");
	return 1;
}

auto disassemble(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));
	lua_pushstring(L, "; disassembler coming soon! ~objective~");
	return 1;
}

auto gettenv(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TTHREAD));
	lua_State* ls = (lua_State*)lua_topointer(L, 1);
	Table* tab = hvalue(luaA_toobject(ls, LUA_GLOBALSINDEX));

	sethvalue(L, L->top, tab);
	L->top++;

	return 1;
}

/* registering */
#if EXPLOIT_DEBUG_MODE
auto getbase(lua_State* L) -> int {
	luaL_stackcheck(L, 0, 0);
	lua_pushnumber(L, rebase(0));
	return 1;
}

auto dumpfunction(lua_State* L) -> int {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TFUNCTION););
	Closure* cl = (Closure*)lua_topointer(L, 1);
	lua_CFunction closure = cl->c.f;
	uintptr_t addr = (uintptr_t)closure;
	lua_pushnumber(L, unbase(addr));
	return 1;
}

auto dumpcontinuation(lua_State* L) -> int {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TFUNCTION););
	Closure* cl = (Closure*)lua_topointer(L, 1);
	lua_Continuation closure = cl->c.cont;
	uintptr_t addr = (uintptr_t)closure;
	lua_pushnumber(L, unbase(addr));
	return 1;
}

auto dumpuserdata(lua_State* L) -> int {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA););
	void* ud = lua_touserdata(L, 1);
	uintptr_t addr = *(uintptr_t*)ud;
	lua_pushnumber(L, addr);
	return 1;
}
#endif

static const luaL_Reg envFuncs[] = {
#if EXPLOIT_DEBUG_MODE
	{"getbase", getbase},
	{"dumpfunction", dumpfunction},
	{"dumpcontinuation", dumpcontinuation},
	{"dumpuserdata", dumpuserdata},
#endif
	{"loadstring", loadstring},

	{"getidentity", getidentity},
	{"getthreadidentity", getidentity},
	{"getthreadcontext", getidentity},
	{"setidentity", setidentity},
	{"setthreadidentity", setidentity},
	{"setthreadcontext", setidentity},
	{"getscriptfromthread", getscriptfromthread},

	{"gethui", gethui},
	{"getgenv", getgenv},
	{"getrenv", getrenv},
	{"getreg", getreg},
	{"getgc", getgc},
	{"getsenv", getsenv},

	{"getconnections", getconnections},
	{"getothersignals", getconnections},
	//{"firesignal", firesignal},

	{"gethiddenproperty", gethiddenproperty},
	{"sethiddenproperty", sethiddenproperty},
	{"isscriptable", isscriptable},
	{"setscriptable", setscriptable},
	{"getproperties", getproperties},
	{"gethiddenproperties", gethiddenproperties},

	{"getinstances", getinstances},
	{"getnilinstances", getnilinstances},

	{"getscriptbytecode", getscriptbytecode},
	{"dumpstring", getscriptbytecode},
	{"getscripthash", getscripthash},

	{"getobjects", module::environment::getobjects},
	{"getcustomasset", getcustomasset},
	{"fireclickdetector", fireclickdetector},
	//{"firetouchinterest", firetouchinterest},
	{"fireproximityprompt", fireproximityprompt},
	{"decompile", decompile},
	{"gettenv", gettenv},
	{"getstateenv", gettenv},


	{NULL, NULL}
};

auto module::environment::createEnv(lua_State* L) -> void {
	lua_pushvalue(L, LUA_GLOBALSINDEX);
	luaL_register(L, NULL, envFuncs);
	lua_pop(L, 1);

	lua_newtable(L);
	lua_setglobal(L, obfuscate_str("_G"));

	lua_newtable(L);
	lua_setglobal(L, obfuscate_str("shared"));
}