#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <lualib.h>

auto renderer{ module::render::getSingleton() };

std::intptr_t drawLineRef = 0, drawCircleRef = 0, drawSquareRef = 0, drawTriangleRef = 0, drawQuadRef = 0, drawTextRef = 0, drawImageRef = 0;
auto vector2_new(lua_State* L, const ImVec2& vector) -> void {
	lua_getfield(L, -10002, obfuscate_str("Vector2"));
	lua_getfield(L, -1, obfuscate_str("new"));

	lua_pushnumber(L, vector.x);
	lua_pushnumber(L, vector.y);

	lua_pcall(L, 2, 1, 0);
}

auto color3_new(lua_State* L, const ImVec4& color) -> void {
	lua_getfield(L, -10002, obfuscate_str("Color3"));
	lua_getfield(L, -1, obfuscate_str("new"));

	lua_pushnumber(L, color.x);
	lua_pushnumber(L, color.y);
	lua_pushnumber(L, color.z);

	lua_pcall(L, 3, 1, 0);
}

auto tovec2(lua_State* L, int index) -> ImVec2 {
	if (strcmp(luaL_typename(L, index), obfuscate_str("Vector2")) != LUA_OK) {
		luaL_typeerror(L, index, "Vector2");
	}

	return *reinterpret_cast<const ImVec2*>(lua_topointer(L, index));
}

auto tocol3(lua_State* L, int index) -> ImVec4 {
	if (strcmp(luaL_typename(L, index), obfuscate_str("Color3")) != LUA_OK) {
		luaL_typeerror(L, index, "Color3");
	}

	return *reinterpret_cast<const module::render::colorType*>(lua_topointer(L, index));
}

namespace module {
	namespace drawingMeta {
		namespace base {
			auto remove(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto item = reinterpret_cast<render::baseType*>(lua_touserdata(L, 1));
				renderer->remove(item);

				return 0;
			}

			auto clear(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 0, 0);
				renderer->clear();
				return 0;
			}

			auto __index(lua_State* L, render::baseType* object, const std::string& index) -> void {
				if (index == "Visible")
					lua_pushboolean(L, object->visible);
				else if (index == "ZIndex")
					lua_pushnumber(L, object->zindex);
				else if (index == "Remove")
					lua_pushcclosure(L, remove, obfuscate_str("DrawingObject.Remove"), 0);
				else if (index == "Destroy")
					lua_pushcclosure(L, remove, obfuscate_str("DrawingObject.Destroy"), 0);
				else if (index == "__OBJECT_EXISTS")
					lua_pushboolean(L, object->objectExist);
				else
					lua_pushnil(L);
			}

			auto __newindex(lua_State* L, render::baseType* object, const std::string& index) -> void {
				if (index == "Visible")
					object->visible = luaL_checkboolean(L, 3);
				else if (index == "ZIndex")
					object->zindex = luaL_checkinteger(L, 3);
			}
		}

		namespace line {
			auto __index(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::lineType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!strcmp(index, "From"))
					vector2_new(L, obj->from);
				else if (!strcmp(index, "To"))
					vector2_new(L, obj->to);
				else if (!strcmp(index, "Color"))
					color3_new(L, obj->color);
				else if (!strcmp(index, "Thickness"))
					lua_pushnumber(L, obj->thickness);
				else if (!strcmp(index, "Transparency"))
					lua_pushnumber(L, obj->transparency);
				else
					base::__index(L, dynamic_cast<render::baseType*>(obj), index);

				return 1;
			};

			auto __newindex(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::lineType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!strcmp(index, "From"))
					obj->from = tovec2(L, 3);
				else if (!strcmp(index, "To"))
					obj->to = tovec2(L, 3);
				else if (!strcmp(index, "Color"))
					obj->color = tocol3(L, 3);
				else if (!strcmp(index, "Thickness"))
					obj->thickness = luaL_checkinteger(L, 3);
				else if (!strcmp(index, "Transparency"))
					obj->transparency = (float)luaL_checknumber(L, 3);
				else
					base::__newindex(L, dynamic_cast<render::baseType*>(obj), index);

				return 0;
			};
		};

		namespace circle {
			auto __index(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::circleType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "Position"))
					vector2_new(L, obj->position);
				else if (!std::strcmp(index, "Radius"))
					lua_pushnumber(L, obj->radius);
				else if (!std::strcmp(index, "Color"))
					color3_new(L, obj->color);
				else if (!std::strcmp(index, "Thickness"))
					lua_pushnumber(L, obj->thickness);
				else if (!std::strcmp(index, "Filled"))
					lua_pushboolean(L, obj->filled);
				else if (!std::strcmp(index, "NumSides"))
					lua_pushnumber(L, obj->numsides);
				else if (!std::strcmp(index, "Transparency"))
					lua_pushnumber(L, obj->transparency);
				else
					base::__index(L, dynamic_cast<render::baseType*>(obj), index);

				return 1;
			};

			auto __newindex(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::circleType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "Position"))
					obj->position = tovec2(L, 3);
				else if (!std::strcmp(index, "Radius"))
					obj->radius = luaL_checkinteger(L, 3);
				else if (!std::strcmp(index, "Color"))
					obj->color = tocol3(L, 3);
				else if (!std::strcmp(index, "Thickness"))
					obj->thickness = luaL_checkinteger(L, 3);
				else if (!std::strcmp(index, "Filled"))
					obj->filled = luaL_checkboolean(L, 3);
				else if (!std::strcmp(index, "NumSides"))
					obj->numsides = luaL_checkinteger(L, 3);
				else if (!std::strcmp(index, "Transparency"))
					obj->transparency = (float)luaL_checknumber(L, 3);
				else
					base::__newindex(L, dynamic_cast<render::baseType*>(obj), index);

				return 0;
			};
		};

		namespace square {
			auto __index(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::squareType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "Position"))
					vector2_new(L, obj->position);
				else if (!std::strcmp(index, "Size"))
					vector2_new(L, obj->size);
				else if (!std::strcmp(index, "Color"))
					color3_new(L, obj->color);
				else if (!std::strcmp(index, "Thickness"))
					lua_pushnumber(L, obj->thickness);
				else if (!std::strcmp(index, "Transparency"))
					lua_pushnumber(L, obj->transparency);
				else if (!std::strcmp(index, "Filled"))
					lua_pushboolean(L, obj->filled);
				else
					base::__index(L, dynamic_cast<render::baseType*>(obj), index);

				return 1;
			};

			auto __newindex(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::squareType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "Position"))
					obj->position = tovec2(L, 3);
				else if (!std::strcmp(index, "Size"))
					obj->size = tovec2(L, 3);
				else if (!std::strcmp(index, "Color"))
					obj->color = tocol3(L, 3);
				else if (!std::strcmp(index, "Thickness"))
					obj->thickness = luaL_checkinteger(L, 3);
				else if (!std::strcmp(index, "Transparency"))
					obj->transparency = (float)luaL_checknumber(L, 3);
				else if (!std::strcmp(index, "Filled"))
					obj->filled = luaL_checkboolean(L, 3);
				else
					base::__newindex(L, dynamic_cast<render::baseType*>(obj), index);

				return 0;
			};
		};

		namespace text {
			auto __index(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::textType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "Text"))
					lua_pushstring(L, obj->text);
				else if (!std::strcmp(index, "Position"))
					vector2_new(L, obj->position);
				else if (!std::strcmp(index, "Color"))
					color3_new(L, obj->color);
				else if (!std::strcmp(index, "Center"))
					lua_pushboolean(L, obj->center);
				else if (!std::strcmp(index, "Outline"))
					lua_pushboolean(L, obj->outline);
				else if (!std::strcmp(index, "OutlineColor"))
					color3_new(L, obj->outlinecolor);
				else if (!std::strcmp(index, "Size"))
					lua_pushnumber(L, obj->size);
				else if (!std::strcmp(index, "Transparency"))
					lua_pushnumber(L, obj->transparency);
				else if (!std::strcmp(index, "Font"))
					lua_pushnumber(L, obj->font);
				else if (!std::strcmp(index, "TextBounds")) {
					auto fonts = renderer->getFonts();
					ImFont* font = fonts.at(obj->font);

					if (font == nullptr)
						font = fonts.at(0);

					const ImVec2 text_size = font->CalcTextSizeA(obj->size, FLT_MAX, 0.0f, obj->text);
					vector2_new(L, text_size);
				}
				else
					base::__index(L, dynamic_cast<render::baseType*>(obj), index);

				return 1;
			};

			auto __newindex(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::textType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "Text")) {
					const char* str = luaL_checklstring(L, 3, nullptr);
#pragma warning(suppress : 4996)
					std::strcpy(obj->text, str);
				}
				else if (!std::strcmp(index, "Position"))
					obj->position = tovec2(L, 3);
				else if (!std::strcmp(index, "Color"))
					obj->color = tocol3(L, 3);
				else if (!std::strcmp(index, "OutlineColor"))
					obj->outlinecolor = tocol3(L, 3);
				else if (!std::strcmp(index, "Center"))
					obj->center = luaL_checkboolean(L, 3);
				else if (!std::strcmp(index, "Outline"))
					obj->outline = luaL_checkboolean(L, 3);
				else if (!std::strcmp(index, "Size"))
					obj->size = (float)luaL_checknumber(L, 3);
				else if (!std::strcmp(index, "Transparency"))
					obj->transparency = (float)luaL_checknumber(L, 3);
				else if (!std::strcmp(index, "Font"))
					obj->font = luaL_checkinteger(L, 3);
				else if (!std::strcmp(index, "TextBounds"))
					luaL_error(L, "TextBounds is a read only property for text");
				else
					base::__newindex(L, dynamic_cast<render::baseType*>(obj), index);

				return 0;
			};
		};

		namespace triangle {
			auto __index(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::triangleType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "PointA"))
					vector2_new(L, obj->pointa);
				else if (!std::strcmp(index, "PointB"))
					vector2_new(L, obj->pointb);
				else if (!std::strcmp(index, "PointC"))
					vector2_new(L, obj->pointc);
				else if (!std::strcmp(index, "Color"))
					color3_new(L, obj->color);
				else if (!std::strcmp(index, "Thickness"))
					lua_pushnumber(L, obj->thickness);
				else if (!std::strcmp(index, "Transparency"))
					lua_pushnumber(L, obj->transparency);
				else if (!std::strcmp(index, "Filled"))
					lua_pushboolean(L, obj->filled);
				else
					base::__index(L, dynamic_cast<render::baseType*>(obj), index);

				return 1;
			};

			auto __newindex(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::triangleType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, ("PointA")))
					obj->pointa = tovec2(L, 3);
				else if (!std::strcmp(index, "PointB"))
					obj->pointb = tovec2(L, 3);
				else if (!std::strcmp(index, "PointC"))
					obj->pointc = tovec2(L, 3);
				else if (!std::strcmp(index, "Color"))
					obj->color = tocol3(L, 3);
				else if (!std::strcmp(index, "Thickness"))
					obj->thickness = luaL_checkinteger(L, 3);
				else if (!std::strcmp(index, "Transparency"))
					obj->transparency = (float)luaL_checknumber(L, 3);
				else if (!std::strcmp(index, "Filled"))
					obj->filled = luaL_checkboolean(L, 3);
				else
					base::__newindex(L, dynamic_cast<render::baseType*>(obj), index);

				return 0;
			};
		};

		namespace quad {
			auto __index(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::quadType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "PointA"))
					vector2_new(L, obj->pointa);
				else if (!std::strcmp(index, "PointB"))
					vector2_new(L, obj->pointb);
				else if (!std::strcmp(index, "PointC"))
					vector2_new(L, obj->pointc);
				else if (!std::strcmp(index, "PointD"))
					vector2_new(L, obj->pointd);
				else if (!std::strcmp(index, "Color"))
					color3_new(L, obj->color);
				else if (!std::strcmp(index, "Thickness"))
					lua_pushnumber(L, obj->thickness);
				else if (!std::strcmp(index, "Transparency"))
					lua_pushnumber(L, obj->transparency);
				else if (!std::strcmp(index, "Filled"))
					lua_pushboolean(L, obj->filled);
				else
					base::__index(L, dynamic_cast<render::baseType*>(obj), index);

				return 1;
			};

			auto __newindex(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::quadType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "PointA"))
					obj->pointa = tovec2(L, 3);
				else if (!std::strcmp(index, "PointB"))
					obj->pointb = tovec2(L, 3);
				else if (!std::strcmp(index, "PointC"))
					obj->pointc = tovec2(L, 3);
				else if (!std::strcmp(index, "PointD"))
					obj->pointd = tovec2(L, 3);
				else if (!std::strcmp(index, "Color"))
					obj->color = tocol3(L, 3);
				else if (!std::strcmp(index, "Thickness"))
					obj->thickness = luaL_checkinteger(L, 3);
				else if (!std::strcmp(index, "Transparency"))
					obj->transparency = (float)luaL_checknumber(L, 3);
				else if (!std::strcmp(index, "Filled"))
					obj->filled = luaL_checkboolean(L, 3);
				else
					base::__newindex(L, dynamic_cast<render::baseType*>(obj), index);

				return 0;
			};
		};

		namespace image {
			auto __index(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::imageType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "Data"))
					lua_pushstring(L, obj->data);
				else if (!std::strcmp(index, "Uri"))
					lua_pushstring(L, obj->data);
				else if (!std::strcmp(index, "Position"))
					vector2_new(L, obj->position);
				else if (!std::strcmp(index, "Color"))
					color3_new(L, obj->color);
				else if (!std::strcmp(index, "Size"))
					vector2_new(L, obj->size);
				else if (!std::strcmp(index, "Rounding"))
					lua_pushnumber(L, obj->rounding);
				else if (!std::strcmp(index, "Transparency"))
					lua_pushnumber(L, obj->transparency);
				else
					base::__index(L, dynamic_cast<render::baseType*>(obj), index);

				return 1;
			};

			auto __newindex(lua_State* L) -> std::intptr_t {
				luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA));
				checkType(L, 2, LUA_TSTRING);

				if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
					luaL_typeerror(L, 1, "DrawingObject");
					return 0;
				}

				const auto obj = reinterpret_cast<render::imageType*>(lua_touserdata(L, 1));
				const auto index = lua_tostring(L, 2);

				if (!std::strcmp(index, "Data")) {
					const char* str = luaL_checklstring(L, 3, nullptr);
					#pragma warning(suppress : 4996)
					std::strcpy(obj->data, str);
				}
				else if (!std::strcmp(index, "Uri")) {
					const char* str = luaL_checklstring(L, 3, nullptr);
#pragma warning(suppress : 4996)
					std::strcpy(obj->data, str);
				}
				else if (!std::strcmp(index, "Position"))
					obj->position = tovec2(L, 3);
				else if (!std::strcmp(index, "Color"))
					obj->color = tocol3(L, 3);
				else if (!std::strcmp(index, "Size"))
					obj->size = tovec2(L, 3);
				else if (!std::strcmp(index, "Rounding"))
					obj->rounding = luaL_checkinteger(L, 3);
				else
					base::__newindex(L, dynamic_cast<render::baseType*>(obj), index);

				return 0;
			};
		};
	}
}

auto drawing_new(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string drawingType = lua_tostring(L, 1);

	if (drawingType == "Line") {
		const auto ud = reinterpret_cast<module::render::lineType*>(lua_newuserdata(L, sizeof(module::render::lineType)));

		*ud = module::render::lineType{};
		ud->type = module::render::Line;

		lua_rawgeti(L, LUA_REGISTRYINDEX, drawLineRef);
		lua_setmetatable(L, -2);

		renderer->add(ud);
	}
	else if (drawingType == "Circle") {
		const auto ud = reinterpret_cast<module::render::circleType*>(lua_newuserdata(L, sizeof(module::render::circleType)));

		*ud = module::render::circleType{};
		ud->type = module::render::Circle;

		lua_rawgeti(L, LUA_REGISTRYINDEX, drawCircleRef);
		lua_setmetatable(L, -2);

		renderer->add(ud);
	}
	else if (drawingType == "Square") {
		const auto ud = reinterpret_cast<module::render::squareType*>(lua_newuserdata(L, sizeof(module::render::squareType)));

		*ud = module::render::squareType{};
		ud->type = module::render::Square;

		lua_rawgeti(L, LUA_REGISTRYINDEX, drawSquareRef);
		lua_setmetatable(L, -2);

		renderer->add(ud);
	}
	else if (drawingType == "Text") {
		const auto ud = reinterpret_cast<module::render::textType*>(lua_newuserdata(L, sizeof(module::render::textType)));

		*ud = module::render::textType{};
		ud->type = module::render::Text;

		lua_rawgeti(L, LUA_REGISTRYINDEX, drawTextRef);
		lua_setmetatable(L, -2);

		renderer->add(ud);
	}
	else if (drawingType == "Triangle") {
		const auto ud = reinterpret_cast<module::render::triangleType*>(lua_newuserdata(L, sizeof(module::render::triangleType)));

		*ud = module::render::triangleType{};
		ud->type = module::render::Triangle;

		lua_rawgeti(L, LUA_REGISTRYINDEX, drawTriangleRef);
		lua_setmetatable(L, -2);

		renderer->add(ud);
	}
	else if (drawingType == "Quad") {
		const auto ud = reinterpret_cast<module::render::quadType*>(lua_newuserdata(L, sizeof(module::render::quadType)));

		*ud = module::render::quadType{};
		ud->type = module::render::Quad;

		lua_rawgeti(L, LUA_REGISTRYINDEX, drawQuadRef);
		lua_setmetatable(L, -2);

		renderer->add(ud);
	}
	else if (drawingType == "Image") {
		const auto ud = reinterpret_cast<module::render::imageType*>(lua_newuserdata(L, sizeof(module::render::imageType)));

		*ud = module::render::imageType{};
		ud->type = module::render::Image;

		lua_rawgeti(L, LUA_REGISTRYINDEX, drawImageRef);
		lua_setmetatable(L, -2);

		renderer->add(ud);
	}
	else
		lua_pushnil(L);

	return 1;
}

auto isrenderobj(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1);
	lua_pushboolean(L, (strcmp(luaL_typename(L, 1), "DrawingObject") == 0));
	return 1;
}

auto getrenderproperty(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
	checkType(L, 2, LUA_TSTRING);

	if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
		luaL_typeerror(L, 1, "DrawingObject");
		return 0;
	}

	const auto obj = reinterpret_cast<module::render::baseType*>(lua_touserdata(L, 1));

	switch (obj->type) {
	case module::render::Line: {
		return module::drawingMeta::line::__index(L);
	}
	case module::render::Circle: {
		return module::drawingMeta::circle::__index(L);
	}
	case module::render::Square: {
		return module::drawingMeta::square::__index(L);
	}
	case module::render::Text: {
		return module::drawingMeta::text::__index(L);
	}
	case module::render::Triangle: {
		return module::drawingMeta::triangle::__index(L);
	}
	case module::render::Quad: {
		return module::drawingMeta::quad::__index(L);
	}
	case module::render::Image: {
		return module::drawingMeta::image::__index(L);
	}
	default:
		return 0;
	}

	return 0;
}

auto setrenderproperty(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 3, 3, checkType(L, 1, LUA_TUSERDATA));
	checkType(L, 2, LUA_TSTRING);

	if (strcmp(luaL_typename(L, 1), obfuscate_str("DrawingObject")) != LUA_OK) {
		luaL_typeerror(L, 1, "DrawingObject");
		return 0;
	}

	const auto obj = reinterpret_cast<module::render::baseType*>(lua_touserdata(L, 1));

	switch (obj->type) {
	case module::render::Line: {
		return module::drawingMeta::line::__newindex(L);
	}
	case module::render::Circle: {
		return module::drawingMeta::circle::__newindex(L);
	}
	case module::render::Square: {
		return module::drawingMeta::square::__newindex(L);
	}
	case module::render::Text: {
		return module::drawingMeta::text::__newindex(L);
	}
	case module::render::Triangle: {
		return module::drawingMeta::triangle::__newindex(L);
	}	
	case module::render::Quad: {
		return module::drawingMeta::quad::__newindex(L);
	}
	case module::render::Image: {
		return module::drawingMeta::image::__newindex(L);
	}
	default:
		return 0;
	}

	return 0;
}

auto cleardrawcache(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 0, 0);
	renderer->clear();
	return 0;
}

/* registering */
static const luaL_Reg drawFuncs[] = {
	{"new", drawing_new},
	{"clear", cleardrawcache},
	{NULL, NULL}
};

static const luaL_Reg envFuncs[] = {
	{"cleardrawcache", cleardrawcache},
	{"getrenderproperty", getrenderproperty},
	{"setrenderproperty", setrenderproperty},

	{"isrenderobj", isrenderobj},
	{"createrenderobj", drawing_new},
	{"createrenderobject", drawing_new},
	{NULL, NULL}
};

auto createMember(lua_State* rl, const char* name, lua_CFunction function) -> void {
	lua_pushcclosure(rl, function, name, 0);
	lua_setfield(rl, -2, name);
}

auto createMetaRef(lua_State* L, int idx = 0) -> std::intptr_t {
	if (idx != 0) {
		lua_rawgeti(L, LUA_REGISTRYINDEX, idx); // get registry.idx

		if (!lua_isnil(L, -1))                     // idx already in use?
			return 0;

		lua_pop(L, 1);
	}

	lua_newtable(L);
	return lua_ref(L, -1);
}

auto module::environment::createDrawing(lua_State* L) -> void {
	{
		drawLineRef = createMetaRef(L);
		createMember(L, obfuscate_str("__index"), module::drawingMeta::line::__index);
		createMember(L, obfuscate_str("__newindex"), module::drawingMeta::line::__newindex);

		lua_pushstring(L, obfuscate_str("DrawingObject"));
		lua_setfield(L, -2, obfuscate_str("__type"));
	}

	{
		drawCircleRef = createMetaRef(L);
		createMember(L, obfuscate_str("__index"), module::drawingMeta::circle::__index);
		createMember(L, obfuscate_str("__newindex"), module::drawingMeta::circle::__newindex);

		lua_pushstring(L, obfuscate_str("DrawingObject"));
		lua_setfield(L, -2, obfuscate_str("__type"));
	}

	{
		drawSquareRef = createMetaRef(L);
		createMember(L, obfuscate_str("__index"), module::drawingMeta::square::__index);
		createMember(L, obfuscate_str("__newindex"), module::drawingMeta::square::__newindex);

		lua_pushstring(L, obfuscate_str("DrawingObject"));
		lua_setfield(L, -2, obfuscate_str("__type"));
	}

	{
		drawTextRef = createMetaRef(L);
		createMember(L, obfuscate_str("__index"), module::drawingMeta::text::__index);
		createMember(L, obfuscate_str("__newindex"), module::drawingMeta::text::__newindex);

		lua_pushstring(L, obfuscate_str("DrawingObject"));
		lua_setfield(L, -2, obfuscate_str("__type"));
	}

	{
		drawTriangleRef = createMetaRef(L);
		createMember(L, obfuscate_str("__index"), module::drawingMeta::triangle::__index);
		createMember(L, obfuscate_str("__newindex"), module::drawingMeta::triangle::__newindex);

		lua_pushstring(L, obfuscate_str("DrawingObject"));
		lua_setfield(L, -2, obfuscate_str("__type"));
	}

	{
		drawQuadRef = createMetaRef(L);
		createMember(L, obfuscate_str("__index"), module::drawingMeta::quad::__index);
		createMember(L, obfuscate_str("__newindex"), module::drawingMeta::quad::__newindex);

		lua_pushstring(L, obfuscate_str("DrawingObject"));
		lua_setfield(L, -2, obfuscate_str("__type"));
	}

	{
		drawImageRef = createMetaRef(L);
		createMember(L, obfuscate_str("__index"), module::drawingMeta::image::__index);
		createMember(L, obfuscate_str("__newindex"), module::drawingMeta::image::__newindex);

		lua_pushstring(L, obfuscate_str("DrawingObject"));
		lua_setfield(L, -2, obfuscate_str("__type"));
	}

	lua_pushvalue(L, LUA_GLOBALSINDEX);
	luaL_register(L, NULL, envFuncs);
	lua_pop(L, 1);

	lua_newtable(L);
	luaL_register(L, NULL, drawFuncs);

	lua_newtable(L);

	lua_pushnumber(L, 0);
	lua_setfield(L, -2, obfuscate_str("UI"));
	lua_pushnumber(L, 1);
	lua_setfield(L, -2, obfuscate_str("System"));
	lua_pushnumber(L, 2);
	lua_setfield(L, -2, obfuscate_str("Plex"));
	lua_pushnumber(L, 3);
	lua_setfield(L, -2, obfuscate_str("Monospace"));

	lua_setfield(L, -2, obfuscate_str("Fonts"));

	lua_setreadonly(L, -1, true);
	lua_setglobal(L, obfuscate_str("Drawing"));
}