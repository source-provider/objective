#include <roblox/exploit/environment/environment.h>
#include <roblox/exploit/classes/bytecode/bytecode.h>
#include <roblox/exploit/classes/yield/yield.h>
#include <dependencies/luau/vm/src/lstate.h>
#include <dependencies/luau/vm/src/lapi.h>
#include <dependencies/luau/vm/src/lgc.h>
#include <lualib.h>

const auto executionC{ module::execution::getSingleton() };

lua_CFunction oldNamecall = nullptr;
lua_CFunction oldIndex = nullptr;

std::vector<const char*> dangerousFunctions = {
	"OpenVideosFolder", "OpenScreenshotsFolder",
	"GetRobuxBalance", "PerformPurchase", "PromptBundlePurchase", "PromptNativePurchase", "PromptProductPurchase", "PromptPurchase", "PromptThirdPartyPurchase",
	"Publish", "GetMessageId", "OpenBrowserWindow", "RequestInternal", "ExecuteJavaScript",
};

auto dangerousFunction(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TUSERDATA));
	luaL_error(L, "Dangerous function is not supported for security reasons.");
	return 0;
}

std::vector<std::string> queueOnTpScripts{};
auto teleportHandlerThread() -> void {
	auto taskScheduler{ module::scheduler::getSingleton() };
	auto storage{ module::storage::getSingleton() };
	auto execution{ module::execution::getSingleton() };
	auto console{ module::console::getSingleton() };

	auto currentDataModel{ taskScheduler->getDataModel() };

	while (true) {
		Sleep(250);
		if (taskScheduler->getRawDataModel() != currentDataModel)
			break;
	}

	Sleep(7500);

	
	
	taskScheduler->reInitialize();

	std::thread(mainThread, storage->find<HMODULE>(obfuscate_str("moduleHandle"))).detach();
	
	execution->send(
		[execution, console](lua_State* L) -> void {
			for (std::string code : queueOnTpScripts) {
				execution->send(code);
			}
			console->writeMode(obfuscate_str("Teleport Handled!"), module::console::info);
		}
	);
}



auto moduleNamecall(lua_State* L) -> std::intptr_t {
	if (L->extra_space->context_level >= 3) { /* I needa fix this because u can prob get it if u set identity to 2 */
		checkType(L, 1, LUA_TUSERDATA);

		const char* namecallMethod = L->namecall->data;
		const auto taskScheduler{ module::scheduler::getSingleton() };
		std::intptr_t self = ((*(intptr_t*)lua_touserdata(L, 1)) - 8);

		if (self == taskScheduler->getDataModel()) {
			if (!strcmp(namecallMethod, obfuscate_str("HttpGet")) || !strcmp(namecallMethod, obfuscate_str("HttpGetAsync"))) {
				return module::environment::httpget(L);
			}
			if (!strcmp(namecallMethod, obfuscate_str("HttpPost")) || !strcmp(namecallMethod, obfuscate_str("HttpPostAsync"))) {
				return module::environment::httppost(L);
			}
			else if (!strcmp(namecallMethod, obfuscate_str("GetObjects")) || !strcmp(namecallMethod, obfuscate_str("GetObjectsAsync"))) {
				return module::environment::getobjects(L);
			}
		}

		for (const char* functionName : dangerousFunctions) {
			if (!strcmp(namecallMethod, functionName)) {
				return dangerousFunction(L);
			}
		}
	}

	return oldNamecall(L);
}

auto moduleIndex(lua_State* L) -> std::intptr_t {
	if (L->extra_space->context_level >= 3) {
		luaL_stackcheck(L, 2, 2, checkType(L, 1, LUA_TUSERDATA));
		checkType(L, 2, LUA_TSTRING);

		const auto taskScheduler{ module::scheduler::getSingleton() };
		std::intptr_t self = ((*(intptr_t*)lua_touserdata(L, 1)) - 8);
		const char* index = lua_tostring(L, 2);
		
		if (self == taskScheduler->getDataModel()) {
			if (!strcmp(index, obfuscate_str("HttpGet")) || !strcmp(index, obfuscate_str("HttpGetAsync"))) {
				lua_pushcclosure(L, module::environment::httpget, index, 0);
				return 1;
			}
			if (!strcmp(index, obfuscate_str("HttpPost")) || !strcmp(index, obfuscate_str("HttpPostAsync"))) {
				lua_pushcclosure(L, module::environment::httppost, index, 0);
				return 1;
			}
			else if (!strcmp(index, obfuscate_str("GetObjects")) || !strcmp(index, obfuscate_str("GetObjectsAsync"))) {
				lua_pushcclosure(L, module::environment::getobjects, index, 0);
				return 1;
			}
		}

		for (const char* functionName : dangerousFunctions) {
			if (!strcmp(index, functionName)) {
				lua_pushcclosure(L, dangerousFunction, index, 0);
				return 1;
			}
		}
	}

	return oldIndex(L);
}

auto teleportHandler(lua_State* L) -> std::intptr_t {
	std::thread(teleportHandlerThread).detach();
	return 0;
}

auto queueonteleport(lua_State* L) -> std::intptr_t {
	luaL_stackcheck(L, 1, 1, checkType(L, 1, LUA_TSTRING));
	std::string code = lua_tostring(L, 1);
	queueOnTpScripts.push_back(code);
	return 0;
}

/* registering */
static const luaL_Reg envFuncs[] = {
	{"queueonteleport", queueonteleport},
	{"queue_on_teleport", queueonteleport},
	{"teleportHandler",teleportHandler},
	{NULL, NULL}
};

auto module::environment::createInit(lua_State* L) -> void {
	lua_pushvalue(L, LUA_GLOBALSINDEX);
	luaL_register(L, NULL, envFuncs);
	lua_pop(L, 1);

	lua_getglobal(L, obfuscate_str("game"));

	executionC->send(
		[L](lua_State*) -> auto {
			if (lua_getmetatable(L, -1)) {
				lua_getfield(L, -1, "__namecall");
				Closure* namecallClosure = (Closure*)lua_topointer(L, -1);
				oldNamecall = namecallClosure->c.f;
				namecallClosure->c.f = moduleNamecall;
				lua_pop(L, 1);

				lua_getfield(L, -1, "__index");
				Closure* indexClosure = (Closure*)lua_topointer(L, -1);
				oldIndex = indexClosure->c.f;
				indexClosure->c.f = moduleIndex;
				lua_pop(L, 3);
			}
		}
	);

	std::string initScript = obfuscate_str(R"(
local clonefunction = clonefunction(clonefunction)
local newcclosure = clonefunction(newcclosure)
local getgenv = clonefunction(getgenv)
local getrenv = clonefunction(getrenv)
local oldHookfunction = clonefunction(hookfunction)
local assert = clonefunction(assert)
local type = clonefunction(type)
local typeof = clonefunction(typeof)
local iscclosure = clonefunction(iscclosure)
local islclosure = clonefunction(islclosure)
local setidentity = clonefunction(setidentity)
local getidentity = clonefunction(getidentity)
local pcall = clonefunction(pcall)
local xpcall = clonefunction(xpcall)
local gettenv = clonefunction(gettenv)
local rawequal = clonefunction(rawequal)
local getreg = clonefunction(getreg)
local readfile = clonefunction(readfile)
local writefile = clonefunction(writefile)
local loadstring = clonefunction(loadstring)
local task_spawn = clonefunction(task.spawn)
local OldGetscriptclosure = clonefunction(getscriptclosure)
local setmetatable = clonefunction(setmetatable)
local rawset = clonefunction(rawset)
local rawget = clonefunction(rawget)
local setfenv = clonefunction(setfenv)
local error = clonefunction(error)

local oTeleportHandler = clonefunction(teleportHandler)
getgenv().teleportHandler = nil

game:GetService("Players").LocalPlayer.OnTeleport:Connect(newcclosure(function(teleportState) 
	if (teleportState == Enum.TeleportState.InProgress) then 
		oTeleportHandler()
	end
end))

local function format_type_error(func_name, arg, type_wanted, val)
	return ([[bad argument %s to '%s' (expected %s, got %s)]]):format(arg, func_name, type_wanted, typeof(val))
end

getgenv().balls = newcclosure(function() 
	return "balls"
end)

getgenv().getscriptclosure = newcclosure(function(script) 
	local func = OldGetscriptclosure(script)
	local env = setmetatable({}, {
		__index = newcclosure(function(self, idx)
			if (rawget(self, idx)) then
				return rawget(self, idx)
			end

			return getrenv()[idx]
		end),

		__newindex = newcclosure(function(self, idx, val)
			rawset(self, idx, val)
		end),
	})

	rawset(env, "script", script)
	return setfenv(func, env)
end)

getgenv().getsenv = newcclosure(function(sc) 
	for i,v in getreg() do 
		if (type(v) == "thread") then 
			local env = gettenv(v)
			if (rawequal(env.script, sc)) then
				return env
			end
		end
	end

	return nil
end)
getgenv().getmenv = getsenv

getgenv().getrunningscripts = newcclosure(function(s) 
	local scripts = {}
	for i,v in getreg() do
		if (type(v) == "thread") then
			local script = gettenv(v).script
			if (script and (script.ClassName == "ModuleScript" or script.ClassName == "LocalScript")) then 
				table.insert(scripts, script)
			end
		end
	end
	return scripts
end)
getgenv().getscripts = getrunningscripts

getgenv().getloadedmodules = newcclosure(function(s) 
	local scripts = {}
	for i,v in getreg() do
		if (type(v) == "thread") then
			local script = gettenv(v).script
			if (script and (script.ClassName == "ModuleScript")) then 
				table.insert(scripts, script)
			end
		end
	end
	return scripts
end)
getgenv().getmodules = getloadedmodules

getgenv().getclipboard = newcclosure(function()
	return readfile("nihonclipboard.txt")
end)
	
getgenv().setclipboard = newcclosure(function(text)
	writefile("nihonclipboard.txt", text)
end)
	
getgenv().toclipboard = setclipboard

getgenv().appendfile = newcclosure(function(file, content) 
	local data = readfile(file)
	writefile(file, data .. content)
end)

getgenv().loadfile = newcclosure(function(file) 
	local data = readfile(file)
	return loadstring(data)
end)

getgenv().dofile = newcclosure(function(file) 
	local data = readfile(file)
	task_spawn(loadstring(data))
end)

getgenv().secure_call = newcclosure(function(func, fake_env, ...) 
    local olds = getfenv().script
    getfenv().script = fakeEnv

    local oldi = getidentity()
    setidentity(2)

    local data = { pcall(func, ...) }

    getfenv().script = olds
    setidentity(oldi)

    if not data[1] then
        warn(data[2])
    else
        data[1] = nil
        return unpack(data)
    end
end)



getgenv().newlclosure = newcclosure(function(closure) 
	assert(typeof(closure) == "function", format_type_error("newlclosure", 1, "function", closure))

	return function(...)
		return closure(...)
	end
end)

getgenv().hookfunction = newcclosure(function(hookTo, hookWith)
	assert(typeof(hookTo) == "function", format_type_error("hookfunction", 1, "function", hookTo))
	assert(typeof(hookWith) == "function", format_type_error("hookfunction", 2, "function", hookWith))

	if iscclosure(hookTo) then 
		if islclosure(hookWith) then 
			hookWith = newcclosure(hookWith)
		end
	else 
		if iscclosure(hookWith) then 
			hookWith = newlclosure(hookWith)
		end
	end

	return oldHookfunction(hookTo, hookWith)
end)

local function lookupify(t)
    local _t = {}
    for k, v in t do
        _t[v] = true
    end
    return _t
end

local function lookupify(t)
    local _t = {}
    for k, v in t do
        _t[v] = true
    end
    return _t
end

--[[local allowed_methods = lookupify{ "__index", "__namecall", "__newindex", "__call", "__concat", "__unm", "__add", "__sub", "__mul", "__div", "__pow", "__mod", "__tostring", "__eq", "__lt", "__le", "__gc", "__len" }
getgenv().hookmetamethod = newcclosure(function(ud, method, fn)
    assert(ud ~= nil, 'invalid argument #1 (object expected)', 0)
    assert(typeof(method) == "string", 'invalid argument #2 (string expected)', 0)
    assert(typeof(fn) == "function", 'invalid argument #3 (function expected)', 0)
    assert(allowed_methods[method], 'invalid argument #2 (function mode expected)', 0)

    local gmt = getrawmetatable(ud)
    local old_fn = rawget(gmt, method)

    if (old_fn == nil and type(old_fn) ~= "function") then 
		return 
	end

    setreadonly(gmt, false)
    rawset(gmt, method, (islclosure(fn) and newcclosure(fn) or fn))
    setreadonly(gmt, true)
    return old_fn
end)]]

getgenv().hookmetamethod = newcclosure(function(ud, method, fn) 
	return hookfunction(rawget(getrawmetatable(ud), method), fn)
end)

--[[local oRequire = clonefunction(getrenv().require)
getgenv().require = newcclosure(function(module)
    local identity = getidentity()
    setidentity(2)

    local data = { pcall(oRequire, module) }
    setidentity(identity)

    if (data[1] == false) then 
        error(data[2], 0)
        return nil;
    end
    
    return data[2]
end)]]

local oldRequire; oldRequire = oldHookfunction(require, newcclosure(function(moduleScript) 
	local isCaller = checkcaller()

	if (isCaller) then 
		local identity = getidentity()
		setidentity(2)

		local success, result = pcall(oldRequire, moduleScript)
		setidentity(identity)

		if (success == false and tostring(result):lower():find("non robloxscript context") ~= nil) then
			return getscriptclosure(moduleScript)()
		elseif (success == false) then 
			error(result, 0)
		end

		return result
	end

	return oldRequire(moduleScript)
end))
)");

	executionC->send(initScript);
}